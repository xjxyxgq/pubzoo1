
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>cluster: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">mysql_tablespace_recycling/cluster/connection.go (0.0%)</option>
				
				<option value="file1">mysql_tablespace_recycling/cluster/discovery.go (4.4%)</option>
				
				<option value="file2">mysql_tablespace_recycling/cluster/external_api.go (28.3%)</option>
				
				<option value="file3">mysql_tablespace_recycling/cluster/master_validator.go (75.9%)</option>
				
				<option value="file4">mysql_tablespace_recycling/cluster/types.go (73.7%)</option>
				
				<option value="file5">mysql_tablespace_recycling/cmd/analyze.go (0.0%)</option>
				
				<option value="file6">mysql_tablespace_recycling/cmd/reclaim.go (0.0%)</option>
				
				<option value="file7">mysql_tablespace_recycling/cmd/root.go (0.0%)</option>
				
				<option value="file8">mysql_tablespace_recycling/cmd/status.go (0.0%)</option>
				
				<option value="file9">mysql_tablespace_recycling/cmd/topology.go (0.0%)</option>
				
				<option value="file10">mysql_tablespace_recycling/cmd/utils.go (0.0%)</option>
				
				<option value="file11">mysql_tablespace_recycling/cmd/validate.go (0.0%)</option>
				
				<option value="file12">mysql_tablespace_recycling/config/config.go (0.0%)</option>
				
				<option value="file13">mysql_tablespace_recycling/main.go (0.0%)</option>
				
				<option value="file14">mysql_tablespace_recycling/monitor/monitor.go (0.0%)</option>
				
				<option value="file15">mysql_tablespace_recycling/pkg/database/connection.go (0.0%)</option>
				
				<option value="file16">mysql_tablespace_recycling/pkg/logger/logger.go (0.0%)</option>
				
				<option value="file17">mysql_tablespace_recycling/recycler/analyzer.go (10.8%)</option>
				
				<option value="file18">mysql_tablespace_recycling/recycler/executor.go (0.0%)</option>
				
				<option value="file19">mysql_tablespace_recycling/recycler/types.go (94.9%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package cluster

import (
        "fmt"
        "time"

        "mysql_tablespace_recycling/pkg/database"
        _ "github.com/go-sql-driver/mysql"
        "database/sql"
)

// DBConnection 数据库连接接口 - 继承通用接口
type DBConnection = database.DBConnection

// MySQLConnection MySQL连接实现
type MySQLConnection struct {
        db *sql.DB
}

// NewMySQLConnection 创建MySQL连接
func NewMySQLConnection(node *NodeConfig) (*MySQLConnection, error) <span class="cov0" title="0">{
        if !node.IsValid() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid node config: %+v", node)
        }</span>

        // 确定要使用的超时值
        <span class="cov0" title="0">connectTimeout := node.Timeout  // 默认连接超时
        readTimeout := node.Timeout    // 默认读超时
        writeTimeout := node.Timeout   // 默认写超时
        
        // 如果设置了具体的超时配置，则使用它们
        if node.ConnectTimeout &gt; 0 </span><span class="cov0" title="0">{
                connectTimeout = node.ConnectTimeout
        }</span>
        <span class="cov0" title="0">if node.QueryTimeout &gt; 0 </span><span class="cov0" title="0">{
                readTimeout = node.QueryTimeout
                writeTimeout = node.QueryTimeout
        }</span>

        <span class="cov0" title="0">dsn := fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?timeout=%s&amp;readTimeout=%s&amp;writeTimeout=%s&amp;parseTime=true",
                node.Username,
                node.Password,
                node.Host,
                node.Port,
                node.Database,
                connectTimeout.String(),
                readTimeout.String(),
                writeTimeout.String(),
        )

        db, err := sql.Open("mysql", dsn)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open connection to %s:%d: %w", node.Host, node.Port, err)
        }</span>

        // 设置连接池参数
        <span class="cov0" title="0">db.SetMaxOpenConns(10)
        db.SetMaxIdleConns(5)
        db.SetConnMaxLifetime(5 * time.Minute)

        conn := &amp;MySQLConnection{db: db}

        // 测试连接
        if err := conn.Ping(); err != nil </span><span class="cov0" title="0">{
                conn.Close()
                return nil, fmt.Errorf("failed to ping %s:%d: %w", node.Host, node.Port, err)
        }</span>

        <span class="cov0" title="0">return conn, nil</span>
}

// Query 执行查询
func (c *MySQLConnection) Query(query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        return c.db.Query(query, args...)
}</span>

// QueryRow 执行单行查询
func (c *MySQLConnection) QueryRow(query string, args ...interface{}) database.RowScanner <span class="cov0" title="0">{
        return c.db.QueryRow(query, args...)
}</span>

// Close 关闭连接
func (c *MySQLConnection) Close() error <span class="cov0" title="0">{
        if c.db != nil </span><span class="cov0" title="0">{
                return c.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Ping 测试连接
func (c *MySQLConnection) Ping() error <span class="cov0" title="0">{
        return c.db.Ping()
}</span>

// ConnectionFactory 连接工厂接口 - 使用通用接口
type ConnectionFactory = database.ConnectionFactory

// DefaultConnectionFactory 默认连接工厂
type DefaultConnectionFactory struct{}

// CreateConnection 创建数据库连接
func (f *DefaultConnectionFactory) CreateConnection(config database.NodeConfigInterface) (database.DBConnection, error) <span class="cov0" title="0">{
        // 转换为cluster的NodeConfig类型
        nodeConfig, ok := config.(*NodeConfig)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("config must be of type *NodeConfig")
        }</span>
        <span class="cov0" title="0">return NewMySQLConnection(nodeConfig)</span>
}</pre>
		
		<pre class="file" id="file1" style="display: none">package cluster

import (
        "context"
        "database/sql"
        "fmt"
        "strconv"
        "strings"
        "sync"
        "sync/atomic"
        "time"
)

// TopologyDiscoverer 拓扑发现器接口
type TopologyDiscoverer interface {
        DiscoverTopology(ctx context.Context, entryPoint *NodeConfig) (*ClusterTopology, error)
        ValidateNode(ctx context.Context, node *NodeConfig) (*NodeStatus, error)
        GetSlaveHosts(ctx context.Context, node *NodeConfig) ([]*SlaveHost, error)
        GetSlaveStatus(ctx context.Context, node *NodeConfig) (*SlaveStatus, error)
}

// DefaultTopologyDiscoverer 默认拓扑发现器实现
type DefaultTopologyDiscoverer struct {
        connectionFactory ConnectionFactory
        options          *DiscoveryOptions
        externalAPI      ExternalAPIClient
        mu               sync.RWMutex
        visitedNodes     map[string]bool
        discoveredNodes  map[string]*NodeConfig
}

// NewTopologyDiscoverer 创建拓扑发现器
func NewTopologyDiscoverer(factory ConnectionFactory, options *DiscoveryOptions) TopologyDiscoverer <span class="cov8" title="1">{
        if options == nil </span><span class="cov8" title="1">{
                options = &amp;DiscoveryOptions{
                        MaxConcurrency: 5,
                        Timeout:        30 * time.Second,
                        MaxDepth:       3,
                }
        }</span>

        <span class="cov8" title="1">return &amp;DefaultTopologyDiscoverer{
                connectionFactory: factory,
                options:          options,
                visitedNodes:     make(map[string]bool),
                discoveredNodes:  make(map[string]*NodeConfig),
        }</span>
}

// DiscoverTopology 发现集群拓扑
func (d *DefaultTopologyDiscoverer) DiscoverTopology(ctx context.Context, entryPoint *NodeConfig) (*ClusterTopology, error) <span class="cov8" title="1">{
        if !entryPoint.IsValid() </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("invalid entry point node config: %+v", entryPoint)
        }</span>

        // 首先验证入口节点是否可连接
        <span class="cov8" title="1">if _, err := d.ValidateNode(ctx, entryPoint); err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to validate entry point: %w", err)
        }</span>

        // 创建带超时的上下文
        <span class="cov0" title="0">ctx, cancel := context.WithTimeout(ctx, d.options.Timeout)
        defer cancel()

        topology := &amp;ClusterTopology{
                Relationships: make(map[string][]string),
                NodeStatuses:  make(map[string]*NodeStatus),
                DiscoveredAt:  time.Now(),
        }

        // 并发发现拓扑
        if err := d.discoverConcurrently(ctx, entryPoint, topology, 0); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to discover topology: %w", err)
        }</span>

        // 分析拓扑关系，找出主节点
        <span class="cov0" title="0">if err := d.analyzeMasterSlave(topology); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to analyze master-slave relationships: %w", err)
        }</span>

        <span class="cov0" title="0">return topology, nil</span>
}

// discoverConcurrently 并发发现拓扑
func (d *DefaultTopologyDiscoverer) discoverConcurrently(ctx context.Context, entryPoint *NodeConfig, topology *ClusterTopology, depth int) error <span class="cov0" title="0">{
        if depth &gt;= d.options.MaxDepth </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 使用信号量控制并发数
        <span class="cov0" title="0">sem := make(chan struct{}, d.options.MaxConcurrency)
        var wg sync.WaitGroup
        var mu sync.Mutex
        var errors []error

        // 待处理的节点队列 - 使用带缓冲的通道
        nodeQueue := make(chan *NodeConfig, 100)
        nodeQueue &lt;- entryPoint

        // 跟踪活跃的goroutines数量
        activeGoroutines := int32(0)

        // 启动worker goroutines
        for i := 0; i &lt; d.options.MaxConcurrency; i++ </span><span class="cov0" title="0">{
                wg.Add(1)
                go func() </span><span class="cov0" title="0">{
                        defer wg.Done()
                        for </span><span class="cov0" title="0">{
                                select </span>{
                                case node, ok := &lt;-nodeQueue:<span class="cov0" title="0">
                                        if !ok </span><span class="cov0" title="0">{
                                                // 队列已关闭
                                                return
                                        }</span>
                                        <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                                                return
                                        }</span>
                                        
                                        <span class="cov0" title="0">sem &lt;- struct{}{}
                                        atomic.AddInt32(&amp;activeGoroutines, 1)
                                        
                                        if err := d.discoverSingleNode(ctx, node, topology, nodeQueue); err != nil </span><span class="cov0" title="0">{
                                                // 收集错误但不立即失败，让拓扑发现继续进行
                                                mu.Lock()
                                                errors = append(errors, err)
                                                mu.Unlock()
                                        }</span>
                                        
                                        <span class="cov0" title="0">atomic.AddInt32(&amp;activeGoroutines, -1)
                                        &lt;-sem</span>
                                case &lt;-ctx.Done():<span class="cov0" title="0">
                                        return</span>
                                }
                        }
                }()
        }

        // 监控队列状态，当队列为空且没有活跃的goroutines时关闭队列
        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                close(nodeQueue)
                                return</span>
                        case &lt;-time.After(100 * time.Millisecond):<span class="cov0" title="0">
                                // 检查是否应该关闭队列
                                if len(nodeQueue) == 0 &amp;&amp; atomic.LoadInt32(&amp;activeGoroutines) == 0 </span><span class="cov0" title="0">{
                                        close(nodeQueue)
                                        return
                                }</span>
                        }
                }
        }()

        // 等待所有goroutines完成
        <span class="cov0" title="0">wg.Wait()

        // 检查错误
        mu.Lock()
        defer mu.Unlock()
        
        // 检查是否成功发现了节点
        discoveredNodes := len(topology.NodeStatuses)
        
        // 如果有错误但成功发现了一些节点，仍然认为是成功的
        if len(errors) &gt; 0 &amp;&amp; discoveredNodes == 0 </span><span class="cov0" title="0">{
                // 如果完全没有发现任何节点，返回第一个错误
                return errors[0]
        }</span>
        
        // 否则认为发现成功（即使有一些节点失败）
        <span class="cov0" title="0">return nil</span>
}

// discoverSingleNode 发现单个节点
func (d *DefaultTopologyDiscoverer) discoverSingleNode(ctx context.Context, node *NodeConfig, topology *ClusterTopology, nodeQueue chan&lt;- *NodeConfig) error <span class="cov0" title="0">{
        nodeKey := node.NodeKey()

        // 检查是否已经访问过
        d.mu.Lock()
        if d.visitedNodes[nodeKey] </span><span class="cov0" title="0">{
                d.mu.Unlock()
                return nil
        }</span>
        <span class="cov0" title="0">d.visitedNodes[nodeKey] = true
        d.discoveredNodes[nodeKey] = node
        d.mu.Unlock()

        // 验证节点状态
        status, err := d.ValidateNode(ctx, node)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate node %s: %w", nodeKey, err)
        }</span>

        // 添加到拓扑
        <span class="cov0" title="0">topology.AddNode(node, status)

        // 获取从库列表
        slaveHosts, err := d.GetSlaveHosts(ctx, node)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get slave hosts for %s: %w", nodeKey, err)
        }</span>

        // 处理从库关系
        <span class="cov0" title="0">var downstreams []string
        for _, slave := range slaveHosts </span><span class="cov0" title="0">{
                slaveKey := fmt.Sprintf("%s:%d", slave.Host, slave.Port)
                downstreams = append(downstreams, slaveKey)

                // 创建从库节点配置
                slaveNode := &amp;NodeConfig{
                        Host:     slave.Host,
                        Port:     slave.Port,
                        Username: node.Username,
                        Password: node.Password,
                        Database: node.Database,
                        Timeout:  node.Timeout,
                }

                // 将从库加入发现队列
                select </span>{
                case nodeQueue &lt;- slaveNode:<span class="cov0" title="0"></span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                        // 队列满了，跳过
                }
        }

        <span class="cov0" title="0">if len(downstreams) &gt; 0 </span><span class="cov0" title="0">{
                d.mu.Lock()
                topology.Relationships[nodeKey] = downstreams
                d.mu.Unlock()
        }</span>

        // 获取上游主库信息
        <span class="cov0" title="0">slaveStatus, err := d.GetSlaveStatus(ctx, node)
        if err == nil &amp;&amp; slaveStatus != nil </span><span class="cov0" title="0">{
                // 这是一个从库，发现上游主库
                masterKey := fmt.Sprintf("%s:%d", slaveStatus.MasterHost, slaveStatus.MasterPort)
                
                d.mu.Lock()
                if _, exists := d.discoveredNodes[masterKey]; !exists </span><span class="cov0" title="0">{
                        // 主库还未发现，加入队列
                        masterNode := &amp;NodeConfig{
                                Host:     slaveStatus.MasterHost,
                                Port:     slaveStatus.MasterPort,
                                Username: node.Username,
                                Password: node.Password,
                                Database: node.Database,
                                Timeout:  node.Timeout,
                        }
                        
                        select </span>{
                        case nodeQueue &lt;- masterNode:<span class="cov0" title="0"></span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                d.mu.Unlock()
                                return ctx.Err()</span>
                        default:<span class="cov0" title="0"></span>
                                // 队列满了，跳过
                        }
                }
                <span class="cov0" title="0">d.mu.Unlock()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// ValidateNode 验证节点状态
func (d *DefaultTopologyDiscoverer) ValidateNode(ctx context.Context, node *NodeConfig) (*NodeStatus, error) <span class="cov8" title="1">{
        conn, err := d.connectionFactory.CreateConnection(node)
        if err != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("failed to connect to %s: %w", node.NodeKey(), err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        status := &amp;NodeStatus{
                LastCheck: time.Now(),
        }

        // 检查read_only状态
        var variableName, readOnlyValue string
        err = conn.QueryRow("SHOW VARIABLES LIKE 'read_only'").Scan(&amp;variableName, &amp;readOnlyValue)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check read_only for %s: %w", node.NodeKey(), err)
        }</span>
        <span class="cov0" title="0">status.IsReadOnly = strings.ToUpper(readOnlyValue) == "ON"

        // 获取server_id
        var serverID uint32
        err = conn.QueryRow("SHOW VARIABLES LIKE 'server_id'").Scan(&amp;variableName, &amp;serverID)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get server_id for %s: %w", node.NodeKey(), err)
        }</span>
        <span class="cov0" title="0">status.ServerID = serverID

        // 获取从库状态
        slaveStatus, err := d.GetSlaveStatus(ctx, node)
        if err == nil &amp;&amp; slaveStatus != nil </span><span class="cov0" title="0">{
                status.SlaveStatus = slaveStatus
                status.IsMaster = false
                status.Role = "从"
        }</span> else<span class="cov0" title="0"> {
                // 没有从库状态，可能是主库
                status.IsMaster = !status.IsReadOnly
                if status.IsMaster </span><span class="cov0" title="0">{
                        status.Role = "主"
                }</span> else<span class="cov0" title="0"> {
                        status.Role = "未知"
                }</span>
        }

        // 获取从库主机列表
        <span class="cov0" title="0">slaveHosts, err := d.GetSlaveHosts(ctx, node)
        if err == nil </span><span class="cov0" title="0">{
                for _, slave := range slaveHosts </span><span class="cov0" title="0">{
                        status.SlaveHosts = append(status.SlaveHosts, fmt.Sprintf("%s:%d", slave.Host, slave.Port))
                }</span>
        }

        // 使用外部API验证（如果可用）
        <span class="cov0" title="0">if d.externalAPI != nil &amp;&amp; d.options.EnableExternalAPI </span><span class="cov0" title="0">{
                if externalInfo, err := d.externalAPI.GetNodeInfo(ctx, node.Host); err == nil </span><span class="cov0" title="0">{
                        // 外部API验证结果优先级更高
                        if externalInfo.InstanceRole == "主" </span><span class="cov0" title="0">{
                                status.IsMaster = true
                                status.Role = "主"
                        }</span> else<span class="cov0" title="0"> {
                                status.IsMaster = false
                                status.Role = externalInfo.InstanceRole
                        }</span>
                        
                        <span class="cov0" title="0">if externalInfo.InstanceReadOnly == "OFF" </span><span class="cov0" title="0">{
                                status.IsReadOnly = false
                        }</span> else<span class="cov0" title="0"> {
                                status.IsReadOnly = true
                        }</span>
                }
        }

        <span class="cov0" title="0">return status, nil</span>
}

// GetSlaveHosts 获取从库主机列表
func (d *DefaultTopologyDiscoverer) GetSlaveHosts(ctx context.Context, node *NodeConfig) ([]*SlaveHost, error) <span class="cov0" title="0">{
        conn, err := d.connectionFactory.CreateConnection(node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to %s: %w", node.NodeKey(), err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        rows, err := conn.Query("SHOW SLAVE HOSTS")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute SHOW SLAVE HOSTS on %s: %w", node.NodeKey(), err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var slaves []*SlaveHost
        for rows.Next() </span><span class="cov0" title="0">{
                var serverID uint32
                var host string
                var port int
                var user sql.NullString

                if err := rows.Scan(&amp;serverID, &amp;host, &amp;port, &amp;user); err != nil </span><span class="cov0" title="0">{
                        continue</span> // 跳过错误的行
                }

                <span class="cov0" title="0">slave := &amp;SlaveHost{
                        ServerID: serverID,
                        Host:     host,
                        Port:     port,
                }
                if user.Valid </span><span class="cov0" title="0">{
                        slave.User = user.String
                }</span>

                <span class="cov0" title="0">slaves = append(slaves, slave)</span>
        }

        <span class="cov0" title="0">return slaves, nil</span>
}

// GetSlaveStatus 获取从库状态
func (d *DefaultTopologyDiscoverer) GetSlaveStatus(ctx context.Context, node *NodeConfig) (*SlaveStatus, error) <span class="cov0" title="0">{
        conn, err := d.connectionFactory.CreateConnection(node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to %s: %w", node.NodeKey(), err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        rows, err := conn.Query("SHOW SLAVE STATUS")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to execute SHOW SLAVE STATUS on %s: %w", node.NodeKey(), err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        if !rows.Next() </span><span class="cov0" title="0">{
                // 没有从库状态，不是从库
                return nil, nil
        }</span>

        // SHOW SLAVE STATUS 返回的列很多，我们只取需要的
        <span class="cov0" title="0">columns, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get columns: %w", err)
        }</span>

        // 创建扫描目标
        <span class="cov0" title="0">values := make([]interface{}, len(columns))
        scanTargets := make([]interface{}, len(columns))
        for i := range values </span><span class="cov0" title="0">{
                scanTargets[i] = &amp;values[i]
        }</span>

        <span class="cov0" title="0">if err := rows.Scan(scanTargets...); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan slave status: %w", err)
        }</span>

        // 解析结果
        <span class="cov0" title="0">status := &amp;SlaveStatus{}
        columnMap := make(map[string]interface{})
        for i, col := range columns </span><span class="cov0" title="0">{
                columnMap[col] = values[i]
        }</span>

        // 提取关键字段
        <span class="cov0" title="0">if val, ok := columnMap["Master_Host"]; ok &amp;&amp; val != nil </span><span class="cov0" title="0">{
                status.MasterHost = string(val.([]byte))
        }</span>
        <span class="cov0" title="0">if val, ok := columnMap["Master_Port"]; ok &amp;&amp; val != nil </span><span class="cov0" title="0">{
                if port, err := strconv.Atoi(string(val.([]byte))); err == nil </span><span class="cov0" title="0">{
                        status.MasterPort = port
                }</span>
        }
        <span class="cov0" title="0">if val, ok := columnMap["Master_User"]; ok &amp;&amp; val != nil </span><span class="cov0" title="0">{
                status.MasterUser = string(val.([]byte))
        }</span>
        <span class="cov0" title="0">if val, ok := columnMap["Slave_IO_Running"]; ok &amp;&amp; val != nil </span><span class="cov0" title="0">{
                status.SlaveIORunning = string(val.([]byte))
        }</span>
        <span class="cov0" title="0">if val, ok := columnMap["Slave_SQL_Running"]; ok &amp;&amp; val != nil </span><span class="cov0" title="0">{
                status.SlaveSQLRunning = string(val.([]byte))
        }</span>
        <span class="cov0" title="0">if val, ok := columnMap["Seconds_Behind_Master"]; ok &amp;&amp; val != nil </span><span class="cov0" title="0">{
                if val != nil </span><span class="cov0" title="0">{
                        if lag, err := strconv.Atoi(string(val.([]byte))); err == nil </span><span class="cov0" title="0">{
                                status.SecondsBehindMaster = &amp;lag
                        }</span>
                }
        }
        <span class="cov0" title="0">if val, ok := columnMap["Master_Log_File"]; ok &amp;&amp; val != nil </span><span class="cov0" title="0">{
                status.MasterLogFile = string(val.([]byte))
        }</span>
        <span class="cov0" title="0">if val, ok := columnMap["Slave_IO_State"]; ok &amp;&amp; val != nil </span><span class="cov0" title="0">{
                status.SlaveIOState = string(val.([]byte))
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}

// analyzeMasterSlave 分析主从关系
func (d *DefaultTopologyDiscoverer) analyzeMasterSlave(topology *ClusterTopology) error <span class="cov0" title="0">{
        var masterCandidates []*NodeConfig
        var slaves []*NodeConfig

        // 分析所有节点
        for nodeKey, status := range topology.NodeStatuses </span><span class="cov0" title="0">{
                // 根据节点key找到对应的NodeConfig
                var node *NodeConfig
                if topology.MasterNode != nil &amp;&amp; topology.MasterNode.NodeKey() == nodeKey </span><span class="cov0" title="0">{
                        node = topology.MasterNode
                }</span> else<span class="cov0" title="0"> {
                        for _, slaveNode := range topology.SlaveNodes </span><span class="cov0" title="0">{
                                if slaveNode.NodeKey() == nodeKey </span><span class="cov0" title="0">{
                                        node = slaveNode
                                        break</span>
                                }
                        }
                }

                <span class="cov0" title="0">if node == nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if status.IsMasterRole() </span><span class="cov0" title="0">{
                        masterCandidates = append(masterCandidates, node)
                }</span> else<span class="cov0" title="0"> {
                        slaves = append(slaves, node)
                }</span>
        }

        // 确定主节点
        <span class="cov0" title="0">if len(masterCandidates) == 1 </span><span class="cov0" title="0">{
                topology.MasterNode = masterCandidates[0]
        }</span> else<span class="cov0" title="0"> if len(masterCandidates) &gt; 1 </span><span class="cov0" title="0">{
                // 多个主节点候选，选择没有上游复制关系的
                for _, candidate := range masterCandidates </span><span class="cov0" title="0">{
                        status := topology.NodeStatuses[candidate.NodeKey()]
                        if status.SlaveStatus == nil </span><span class="cov0" title="0">{
                                topology.MasterNode = candidate
                                break</span>
                        }
                }
                <span class="cov0" title="0">if topology.MasterNode == nil </span><span class="cov0" title="0">{
                        topology.MasterNode = masterCandidates[0] // 降级选择第一个
                }</span>
        }

        // 设置从节点列表
        <span class="cov0" title="0">topology.SlaveNodes = slaves
        topology.TotalNodes = len(topology.NodeStatuses)

        return nil</span>
}

// ExternalAPIClient 外部API客户端接口
type ExternalAPIClient interface {
        GetNodeInfo(ctx context.Context, host string) (*ExternalNodeInfo, error)
}</pre>
		
		<pre class="file" id="file2" style="display: none">package cluster

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "net/http"
        "sync"
        "time"
)

// HTTPExternalAPIClient HTTP外部API客户端
type HTTPExternalAPIClient struct {
        baseURL    string
        httpClient *http.Client
        cache      map[string]*cachedNodeInfo
        cacheMu    sync.RWMutex
        cacheTTL   time.Duration
}

// cachedNodeInfo 缓存的节点信息
type cachedNodeInfo struct {
        info      *ExternalNodeInfo
        timestamp time.Time
}

// NewHTTPExternalAPIClient 创建HTTP外部API客户端
func NewHTTPExternalAPIClient(baseURL string, timeout time.Duration, cacheTTL time.Duration) *HTTPExternalAPIClient <span class="cov8" title="1">{
        return &amp;HTTPExternalAPIClient{
                baseURL: baseURL,
                httpClient: &amp;http.Client{
                        Timeout: timeout,
                },
                cache:    make(map[string]*cachedNodeInfo),
                cacheTTL: cacheTTL,
        }
}</span>

// GetNodeInfo 获取节点信息
func (c *HTTPExternalAPIClient) GetNodeInfo(ctx context.Context, host string) (*ExternalNodeInfo, error) <span class="cov0" title="0">{
        // 检查缓存
        if info := c.getCachedNodeInfo(host); info != nil </span><span class="cov0" title="0">{
                return info, nil
        }</span>

        // 准备请求数据
        <span class="cov0" title="0">requestData := map[string]string{
                "search_ins_ip": host,
        }

        jsonData, err := json.Marshal(requestData)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to marshal request data: %w", err)
        }</span>

        // 创建HTTP请求
        <span class="cov0" title="0">req, err := http.NewRequestWithContext(ctx, "POST", c.baseURL, bytes.NewBuffer(jsonData))
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to create HTTP request: %w", err)
        }</span>

        <span class="cov0" title="0">req.Header.Set("Content-Type", "application/json")

        // 发送请求
        resp, err := c.httpClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to send HTTP request: %w", err)
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if resp.StatusCode != http.StatusOK </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("HTTP request failed with status: %d", resp.StatusCode)
        }</span>

        // 解析响应
        <span class="cov0" title="0">var apiResp ExternalAPIResponse
        if err := json.NewDecoder(resp.Body).Decode(&amp;apiResp); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to decode response: %w", err)
        }</span>

        <span class="cov0" title="0">if apiResp.Status != "ok" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned error status: %s", apiResp.Status)
        }</span>

        <span class="cov0" title="0">if apiResp.Data == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("API returned no data")
        }</span>

        // 缓存结果
        <span class="cov0" title="0">c.cacheNodeInfo(host, apiResp.Data)

        return apiResp.Data, nil</span>
}

// getCachedNodeInfo 获取缓存的节点信息
func (c *HTTPExternalAPIClient) getCachedNodeInfo(host string) *ExternalNodeInfo <span class="cov8" title="1">{
        c.cacheMu.RLock()
        defer c.cacheMu.RUnlock()

        cached, exists := c.cache[host]
        if !exists </span><span class="cov8" title="1">{
                return nil
        }</span>

        // 检查缓存是否过期
        <span class="cov8" title="1">if time.Since(cached.timestamp) &gt; c.cacheTTL </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return cached.info</span>
}

// cacheNodeInfo 缓存节点信息
func (c *HTTPExternalAPIClient) cacheNodeInfo(host string, info *ExternalNodeInfo) <span class="cov8" title="1">{
        c.cacheMu.Lock()
        defer c.cacheMu.Unlock()

        c.cache[host] = &amp;cachedNodeInfo{
                info:      info,
                timestamp: time.Now(),
        }
}</span>

// ClearCache 清理缓存
func (c *HTTPExternalAPIClient) ClearCache() <span class="cov8" title="1">{
        c.cacheMu.Lock()
        defer c.cacheMu.Unlock()

        c.cache = make(map[string]*cachedNodeInfo)
}</span>

// CleanupExpiredCache 清理过期缓存
func (c *HTTPExternalAPIClient) CleanupExpiredCache() <span class="cov0" title="0">{
        c.cacheMu.Lock()
        defer c.cacheMu.Unlock()

        now := time.Now()
        for host, cached := range c.cache </span><span class="cov0" title="0">{
                if now.Sub(cached.timestamp) &gt; c.cacheTTL </span><span class="cov0" title="0">{
                        delete(c.cache, host)
                }</span>
        }
}

// StartCacheCleanup 启动缓存清理goroutine
func (c *HTTPExternalAPIClient) StartCacheCleanup(ctx context.Context, interval time.Duration) <span class="cov0" title="0">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-ticker.C:<span class="cov0" title="0">
                                c.CleanupExpiredCache()</span>
                        case &lt;-ctx.Done():<span class="cov0" title="0">
                                return</span>
                        }
                }
        }()
}</pre>
		
		<pre class="file" id="file3" style="display: none">package cluster

import (
        "context"
        "fmt"
        "strings"
)

// MasterValidator 主节点验证器接口
type MasterValidator interface {
        IsMasterNode(ctx context.Context, node *NodeConfig) (bool, error)
        ValidateMasterSafety(ctx context.Context, node *NodeConfig) error
        GetMasterValidationResult(ctx context.Context, node *NodeConfig) (*MasterValidationResult, error)
}

// MasterValidationResult 主节点验证结果
type MasterValidationResult struct {
        IsMaster           bool                  `json:"is_master"`
        ValidationMethods  []ValidationMethod    `json:"validation_methods"`
        Confidence         ValidationConfidence  `json:"confidence"`
        Reasons            []string              `json:"reasons"`
        Warnings           []string              `json:"warnings"`
        ExternalAPIResult  *ExternalNodeInfo     `json:"external_api_result,omitempty"`
        DatabaseStatus     *DatabaseMasterStatus `json:"database_status"`
}

// ValidationMethod 验证方法
type ValidationMethod string

const (
        ValidationReadOnly     ValidationMethod = "read_only_check"
        ValidationSlaveStatus  ValidationMethod = "slave_status_check"
        ValidationSlaveHosts   ValidationMethod = "slave_hosts_check"
        ValidationExternalAPI  ValidationMethod = "external_api_check"
        ValidationProcessList  ValidationMethod = "process_list_check"
)

// ValidationConfidence 验证信心度
type ValidationConfidence string

const (
        ConfidenceHigh   ValidationConfidence = "high"
        ConfidenceMedium ValidationConfidence = "medium"
        ConfidenceLow    ValidationConfidence = "low"
        ConfidenceNone   ValidationConfidence = "none"
)

// DatabaseMasterStatus 数据库主节点状态
type DatabaseMasterStatus struct {
        ReadOnly              bool     `json:"read_only"`
        SuperReadOnly         bool     `json:"super_read_only"`
        HasSlaveConnections   bool     `json:"has_slave_connections"`
        SlaveCount            int      `json:"slave_count"`
        HasSlaveStatus        bool     `json:"has_slave_status"`
        ServerID              uint32   `json:"server_id"`
        LogBin                bool     `json:"log_bin"`
        BinlogFormat          string   `json:"binlog_format"`
        ActiveConnections     int      `json:"active_connections"`
        ReplicationUsers      []string `json:"replication_users"`
}

// DefaultMasterValidator 默认主节点验证器
type DefaultMasterValidator struct {
        discoverer    TopologyDiscoverer
        externalAPI   ExternalAPIClient
        factory       ConnectionFactory
        strictMode    bool
}

// NewMasterValidator 创建主节点验证器
func NewMasterValidator(discoverer TopologyDiscoverer, externalAPI ExternalAPIClient, factory ConnectionFactory, strictMode bool) MasterValidator <span class="cov8" title="1">{
        return &amp;DefaultMasterValidator{
                discoverer:  discoverer,
                externalAPI: externalAPI,
                factory:     factory,
                strictMode:  strictMode,
        }
}</span>

// IsMasterNode 检查是否为主节点
func (v *DefaultMasterValidator) IsMasterNode(ctx context.Context, node *NodeConfig) (bool, error) <span class="cov8" title="1">{
        result, err := v.GetMasterValidationResult(ctx, node)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        
        // 在严格模式下需要高信心度
        <span class="cov8" title="1">if v.strictMode &amp;&amp; result.Confidence != ConfidenceHigh </span><span class="cov8" title="1">{
                return false, fmt.Errorf("master validation confidence too low: %s", result.Confidence)
        }</span>
        
        <span class="cov8" title="1">return result.IsMaster, nil</span>
}

// ValidateMasterSafety 验证主节点操作安全性
func (v *DefaultMasterValidator) ValidateMasterSafety(ctx context.Context, node *NodeConfig) error <span class="cov8" title="1">{
        result, err := v.GetMasterValidationResult(ctx, node)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to validate master: %w", err)
        }</span>
        
        <span class="cov8" title="1">if result.IsMaster </span><span class="cov8" title="1">{
                return fmt.Errorf("operation blocked: target node identified as master node")
        }</span>
        
        // 检查警告
        <span class="cov0" title="0">if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                warningMsg := fmt.Sprintf("master validation warnings: %s", strings.Join(result.Warnings, "; "))
                if v.strictMode </span><span class="cov0" title="0">{
                        return fmt.Errorf("operation blocked due to warnings in strict mode: %s", warningMsg)
                }</span>
                // 非严格模式只记录警告
                <span class="cov0" title="0">fmt.Printf("Warning: %s\n", warningMsg)</span>
        }
        
        <span class="cov0" title="0">return nil</span>
}

// GetMasterValidationResult 获取完整的主节点验证结果
func (v *DefaultMasterValidator) GetMasterValidationResult(ctx context.Context, node *NodeConfig) (*MasterValidationResult, error) <span class="cov8" title="1">{
        result := &amp;MasterValidationResult{
                ValidationMethods: []ValidationMethod{},
                Reasons:          []string{},
                Warnings:         []string{},
                DatabaseStatus:   &amp;DatabaseMasterStatus{},
        }
        
        // 1. 数据库状态检查
        if err := v.checkDatabaseStatus(ctx, node, result); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to check database status: %w", err)
        }</span>
        
        // 2. 外部API检查（如果可用）
        <span class="cov8" title="1">if v.externalAPI != nil </span><span class="cov8" title="1">{
                v.checkExternalAPI(ctx, node, result)
        }</span>
        
        // 3. 拓扑关系检查
        <span class="cov8" title="1">if err := v.checkTopologyRelationship(ctx, node, result); err != nil </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, fmt.Sprintf("topology check failed: %v", err))
        }</span>
        
        // 4. 综合判断
        <span class="cov8" title="1">v.calculateFinalResult(result)
        
        return result, nil</span>
}

// checkDatabaseStatus 检查数据库状态
func (v *DefaultMasterValidator) checkDatabaseStatus(ctx context.Context, node *NodeConfig, result *MasterValidationResult) error <span class="cov8" title="1">{
        conn, err := v.factory.CreateConnection(node)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect to %s: %w", node.NodeKey(), err)
        }</span>
        <span class="cov8" title="1">defer conn.Close()
        
        dbStatus := result.DatabaseStatus
        
        // 检查read_only状态
        var variableName, readOnlyValue string
        err = conn.QueryRow("SHOW VARIABLES LIKE 'read_only'").Scan(&amp;variableName, &amp;readOnlyValue)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check read_only: %w", err)
        }</span>
        <span class="cov8" title="1">dbStatus.ReadOnly = strings.ToUpper(readOnlyValue) == "ON"
        result.ValidationMethods = append(result.ValidationMethods, ValidationReadOnly)
        
        if !dbStatus.ReadOnly </span><span class="cov8" title="1">{
                result.Reasons = append(result.Reasons, "read_only=OFF (master characteristic)")
        }</span> else<span class="cov8" title="1"> {
                result.Reasons = append(result.Reasons, "read_only=ON (slave characteristic)")
        }</span>
        
        // 检查super_read_only状态
        <span class="cov8" title="1">var superReadOnlyValue string
        err = conn.QueryRow("SHOW VARIABLES LIKE 'super_read_only'").Scan(&amp;variableName, &amp;superReadOnlyValue)
        if err == nil </span><span class="cov8" title="1">{
                dbStatus.SuperReadOnly = strings.ToUpper(superReadOnlyValue) == "ON"
                if dbStatus.SuperReadOnly </span><span class="cov8" title="1">{
                        result.Reasons = append(result.Reasons, "super_read_only=ON")
                }</span>
        }
        
        // 检查server_id
        <span class="cov8" title="1">var serverID uint32
        err = conn.QueryRow("SHOW VARIABLES LIKE 'server_id'").Scan(&amp;variableName, &amp;serverID)
        if err == nil </span><span class="cov8" title="1">{
                dbStatus.ServerID = serverID
                if serverID == 0 </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, "server_id is 0, replication not properly configured")
                }</span>
        }
        
        // 检查binlog状态
        <span class="cov8" title="1">var logBinValue string
        err = conn.QueryRow("SHOW VARIABLES LIKE 'log_bin'").Scan(&amp;variableName, &amp;logBinValue)
        if err == nil </span><span class="cov8" title="1">{
                dbStatus.LogBin = strings.ToUpper(logBinValue) == "ON"
                if !dbStatus.LogBin </span><span class="cov0" title="0">{
                        result.Warnings = append(result.Warnings, "binary logging is disabled")
                }</span>
        }
        
        // 检查binlog格式
        <span class="cov8" title="1">var binlogFormatValue string
        err = conn.QueryRow("SHOW VARIABLES LIKE 'binlog_format'").Scan(&amp;variableName, &amp;binlogFormatValue)
        if err == nil </span><span class="cov8" title="1">{
                dbStatus.BinlogFormat = binlogFormatValue
        }</span>
        
        // 检查SLAVE STATUS
        <span class="cov8" title="1">slaveStatus, err := v.discoverer.GetSlaveStatus(ctx, node)
        if err == nil &amp;&amp; slaveStatus != nil </span><span class="cov8" title="1">{
                dbStatus.HasSlaveStatus = true
                result.ValidationMethods = append(result.ValidationMethods, ValidationSlaveStatus)
                result.Reasons = append(result.Reasons, 
                        fmt.Sprintf("has slave status (master: %s:%d)", slaveStatus.MasterHost, slaveStatus.MasterPort))
        }</span> else<span class="cov8" title="1"> {
                result.ValidationMethods = append(result.ValidationMethods, ValidationSlaveStatus)
                result.Reasons = append(result.Reasons, "no slave status (potential master)")
        }</span>
        
        // 检查SLAVE HOSTS
        <span class="cov8" title="1">slaveHosts, err := v.discoverer.GetSlaveHosts(ctx, node)
        if err == nil &amp;&amp; len(slaveHosts) &gt; 0 </span><span class="cov8" title="1">{
                dbStatus.HasSlaveConnections = true
                dbStatus.SlaveCount = len(slaveHosts)
                result.ValidationMethods = append(result.ValidationMethods, ValidationSlaveHosts)
                result.Reasons = append(result.Reasons, 
                        fmt.Sprintf("has %d slave connections", len(slaveHosts)))
                        
                // 记录从库信息
                for _, slave := range slaveHosts </span><span class="cov8" title="1">{
                        dbStatus.ReplicationUsers = append(dbStatus.ReplicationUsers, slave.User)
                }</span>
        }
        
        // 检查进程列表中的复制连接
        <span class="cov8" title="1">v.checkProcessList(ctx, conn, result)
        
        return nil</span>
}

// checkExternalAPI 检查外部API
func (v *DefaultMasterValidator) checkExternalAPI(ctx context.Context, node *NodeConfig, result *MasterValidationResult) <span class="cov8" title="1">{
        externalInfo, err := v.externalAPI.GetNodeInfo(ctx, node.Host)
        if err != nil </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, fmt.Sprintf("external API check failed: %v", err))
                return
        }</span>
        
        <span class="cov8" title="1">result.ExternalAPIResult = externalInfo
        result.ValidationMethods = append(result.ValidationMethods, ValidationExternalAPI)
        
        if externalInfo.InstanceRole == "主" </span><span class="cov8" title="1">{
                result.Reasons = append(result.Reasons, "external API confirms master role")
        }</span> else<span class="cov8" title="1"> {
                result.Reasons = append(result.Reasons, 
                        fmt.Sprintf("external API role: %s", externalInfo.InstanceRole))
        }</span>
        
        <span class="cov8" title="1">if externalInfo.InstanceReadOnly == "OFF" </span><span class="cov8" title="1">{
                result.Reasons = append(result.Reasons, "external API confirms read_only=OFF")
        }</span>
}

// checkTopologyRelationship 检查拓扑关系
func (v *DefaultMasterValidator) checkTopologyRelationship(ctx context.Context, node *NodeConfig, result *MasterValidationResult) error <span class="cov8" title="1">{
        // 这里可以实现更复杂的拓扑关系检查
        // 例如检查节点在集群中的位置等
        return nil
}</span>

// checkProcessList 检查进程列表
func (v *DefaultMasterValidator) checkProcessList(ctx context.Context, conn DBConnection, result *MasterValidationResult) <span class="cov8" title="1">{
        rows, err := conn.Query("SHOW PROCESSLIST")
        if err != nil </span><span class="cov0" title="0">{
                result.Warnings = append(result.Warnings, fmt.Sprintf("failed to check process list: %v", err))
                return
        }</span>
        
        <span class="cov8" title="1">if rows != nil </span><span class="cov0" title="0">{
                defer rows.Close()
        }</span>
        
        <span class="cov8" title="1">result.ValidationMethods = append(result.ValidationMethods, ValidationProcessList)
        
        activeConnections := 0
        replicationConnections := 0
        
        // 简化的进程列表检查 - 由于接口限制，这里先做基础统计
        result.DatabaseStatus.ActiveConnections = activeConnections
        
        if replicationConnections &gt; 0 </span><span class="cov0" title="0">{
                result.Reasons = append(result.Reasons, 
                        fmt.Sprintf("found %d replication connections in process list", replicationConnections))
        }</span>
}

// calculateFinalResult 计算最终结果
func (v *DefaultMasterValidator) calculateFinalResult(result *MasterValidationResult) <span class="cov8" title="1">{
        dbStatus := result.DatabaseStatus
        
        // 基础判断：如果有slave status，很可能是从节点
        if dbStatus.HasSlaveStatus </span><span class="cov8" title="1">{
                result.IsMaster = false
                result.Confidence = ConfidenceHigh
                return
        }</span>
        
        // 主要判断依据
        <span class="cov8" title="1">masterIndicators := 0
        slaveIndicators := 0
        
        // read_only状态是最重要的指标
        if !dbStatus.ReadOnly </span><span class="cov8" title="1">{
                masterIndicators += 3
        }</span> else<span class="cov0" title="0"> {
                slaveIndicators += 3
        }</span>
        
        // super_read_only状态
        <span class="cov8" title="1">if dbStatus.SuperReadOnly </span><span class="cov0" title="0">{
                slaveIndicators += 2
        }</span>
        
        // 有从库连接
        <span class="cov8" title="1">if dbStatus.HasSlaveConnections </span><span class="cov8" title="1">{
                masterIndicators += 2
        }</span>
        
        // 外部API结果
        <span class="cov8" title="1">if result.ExternalAPIResult != nil </span><span class="cov8" title="1">{
                if result.ExternalAPIResult.InstanceRole == "主" </span><span class="cov8" title="1">{
                        masterIndicators += 3
                }</span> else<span class="cov0" title="0"> {
                        slaveIndicators += 2
                }</span>
        }
        
        // binlog开启状态
        <span class="cov8" title="1">if dbStatus.LogBin </span><span class="cov8" title="1">{
                masterIndicators += 1
        }</span>
        
        // 计算结果
        <span class="cov8" title="1">if masterIndicators &gt; slaveIndicators </span><span class="cov8" title="1">{
                result.IsMaster = true
                if masterIndicators &gt;= 5 &amp;&amp; len(result.ValidationMethods) &gt;= 3 </span><span class="cov8" title="1">{
                        result.Confidence = ConfidenceHigh
                }</span> else<span class="cov8" title="1"> if masterIndicators &gt;= 3 </span><span class="cov8" title="1">{
                        result.Confidence = ConfidenceMedium
                }</span> else<span class="cov0" title="0"> {
                        result.Confidence = ConfidenceLow
                }</span>
        } else<span class="cov0" title="0"> if slaveIndicators &gt; masterIndicators </span><span class="cov0" title="0">{
                result.IsMaster = false
                if slaveIndicators &gt;= 5 &amp;&amp; len(result.ValidationMethods) &gt;= 3 </span><span class="cov0" title="0">{
                        result.Confidence = ConfidenceHigh
                }</span> else<span class="cov0" title="0"> if slaveIndicators &gt;= 3 </span><span class="cov0" title="0">{
                        result.Confidence = ConfidenceMedium
                }</span> else<span class="cov0" title="0"> {
                        result.Confidence = ConfidenceLow
                }</span>
        } else<span class="cov0" title="0"> {
                // 无法确定
                result.IsMaster = false // 安全起见，默认不是主节点
                result.Confidence = ConfidenceNone
                result.Warnings = append(result.Warnings, "unable to determine master status with confidence")
        }</span>
}</pre>
		
		<pre class="file" id="file4" style="display: none">package cluster

import (
        "fmt"
        "time"
)

// NodeConfig MySQL节点配置
type NodeConfig struct {
        Host     string        `json:"host" yaml:"host"`
        Port     int           `json:"port" yaml:"port"`
        Username string        `json:"username" yaml:"username"`
        Password string        `json:"password" yaml:"password"`
        Database string        `json:"database" yaml:"database"`
        Timeout  time.Duration `json:"timeout" yaml:"timeout"`
        
        // 扩展超时配置
        ConnectTimeout   time.Duration `json:"connect_timeout,omitempty" yaml:"connect_timeout,omitempty"`
        QueryTimeout     time.Duration `json:"query_timeout,omitempty" yaml:"query_timeout,omitempty"`
        AlterTimeout     time.Duration `json:"alter_timeout,omitempty" yaml:"alter_timeout,omitempty"`
        DiscoveryTimeout time.Duration `json:"discovery_timeout,omitempty" yaml:"discovery_timeout,omitempty"`
}

// NodeStatus 节点状态信息
type NodeStatus struct {
        IsMaster    bool          `json:"is_master"`
        IsReadOnly  bool          `json:"is_read_only"`
        Role        string        `json:"role"`
        SlaveStatus *SlaveStatus  `json:"slave_status,omitempty"`
        SlaveHosts  []string      `json:"slave_hosts,omitempty"`
        LastCheck   time.Time     `json:"last_check"`
        ServerID    uint32        `json:"server_id"`
}

// SlaveStatus 从库状态信息
type SlaveStatus struct {
        MasterHost             string `json:"master_host"`
        MasterPort             int    `json:"master_port"`
        MasterUser             string `json:"master_user"`
        SlaveIORunning         string `json:"slave_io_running"`
        SlaveSQLRunning        string `json:"slave_sql_running"`
        SecondsBehindMaster    *int   `json:"seconds_behind_master,omitempty"`
        MasterLogFile          string `json:"master_log_file"`
        ReadMasterLogPos       uint64 `json:"read_master_log_pos"`
        RelayLogFile           string `json:"relay_log_file"`
        RelayLogPos            uint64 `json:"relay_log_pos"`
        RelayMasterLogFile     string `json:"relay_master_log_file"`
        SlaveIOState           string `json:"slave_io_state"`
        ReplicationLag         int    `json:"replication_lag"`
}

// SlaveHost 从库主机信息
type SlaveHost struct {
        ServerID uint32 `json:"server_id"`
        Host     string `json:"host"`
        Port     int    `json:"port"`
        User     string `json:"user,omitempty"`
}

// ClusterTopology 集群拓扑结构
type ClusterTopology struct {
        MasterNode    *NodeConfig            `json:"master_node"`
        SlaveNodes    []*NodeConfig          `json:"slave_nodes"`
        Relationships map[string][]string    `json:"relationships"`
        NodeStatuses  map[string]*NodeStatus `json:"node_statuses"`
        DiscoveredAt  time.Time              `json:"discovered_at"`
        TotalNodes    int                    `json:"total_nodes"`
}

// ExternalNodeInfo 外部API返回的节点信息
type ExternalNodeInfo struct {
        ClusterName      string `json:"cluster_name"`
        ClusterGroupName string `json:"cluster_group_name"`
        InstanceRole     string `json:"instance_role"`
        InstanceReadOnly string `json:"instance_read_only"`
}

// ExternalAPIResponse 外部API响应格式
type ExternalAPIResponse struct {
        Status string            `json:"status"`
        Data   *ExternalNodeInfo `json:"data"`
}

// DiscoveryOptions 拓扑发现选项
type DiscoveryOptions struct {
        MaxConcurrency    int           `json:"max_concurrency"`
        Timeout           time.Duration `json:"timeout"`
        MaxDepth          int           `json:"max_depth"`
        EnableExternalAPI bool          `json:"enable_external_api"`
        ExternalAPIURL    string        `json:"external_api_url"`
}

// NodeKey 生成节点的唯一标识
func (n *NodeConfig) NodeKey() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s:%d", n.Host, n.Port)
}</span>

// IsValid 检查节点配置是否有效
func (n *NodeConfig) IsValid() bool <span class="cov8" title="1">{
        return n.Host != "" &amp;&amp; n.Port &gt; 0 &amp;&amp; n.Username != ""
}</span>

// GetHost 获取主机地址
func (n *NodeConfig) GetHost() string <span class="cov0" title="0">{
        return n.Host
}</span>

// GetPort 获取端口号
func (n *NodeConfig) GetPort() int <span class="cov0" title="0">{
        return n.Port
}</span>

// GetUsername 获取用户名
func (n *NodeConfig) GetUsername() string <span class="cov0" title="0">{
        return n.Username
}</span>

// GetPassword 获取密码
func (n *NodeConfig) GetPassword() string <span class="cov0" title="0">{
        return n.Password
}</span>

// GetDatabase 获取数据库名
func (n *NodeConfig) GetDatabase() string <span class="cov0" title="0">{
        return n.Database
}</span>

// GetTimeout 获取超时时间
func (n *NodeConfig) GetTimeout() time.Duration <span class="cov0" title="0">{
        return n.Timeout
}</span>

// IsMasterRole 检查是否为主节点角色
func (s *NodeStatus) IsMasterRole() bool <span class="cov8" title="1">{
        return s.IsMaster &amp;&amp; !s.IsReadOnly &amp;&amp; s.SlaveStatus == nil
}</span>

// HasSlaves 检查是否有从库
func (s *NodeStatus) HasSlaves() bool <span class="cov8" title="1">{
        return len(s.SlaveHosts) &gt; 0
}</span>

// IsHealthy 检查从库复制状态是否健康
func (s *SlaveStatus) IsHealthy() bool <span class="cov8" title="1">{
        return s.SlaveIORunning == "Yes" &amp;&amp; s.SlaveSQLRunning == "Yes"
}</span>

// GetReplicationDelay 获取复制延迟
func (s *SlaveStatus) GetReplicationDelay() int <span class="cov8" title="1">{
        if s.SecondsBehindMaster == nil </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">return *s.SecondsBehindMaster</span>
}

// AddNode 添加节点到拓扑
func (t *ClusterTopology) AddNode(node *NodeConfig, status *NodeStatus) <span class="cov8" title="1">{
        key := node.NodeKey()
        
        if status.IsMasterRole() </span><span class="cov8" title="1">{
                t.MasterNode = node
        }</span> else<span class="cov8" title="1"> {
                t.SlaveNodes = append(t.SlaveNodes, node)
        }</span>
        
        <span class="cov8" title="1">if t.NodeStatuses == nil </span><span class="cov8" title="1">{
                t.NodeStatuses = make(map[string]*NodeStatus)
        }</span>
        <span class="cov8" title="1">t.NodeStatuses[key] = status
        
        t.TotalNodes = len(t.NodeStatuses)</span>
}

// GetNodeStatus 获取节点状态
func (t *ClusterTopology) GetNodeStatus(node *NodeConfig) *NodeStatus <span class="cov0" title="0">{
        if t.NodeStatuses == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return t.NodeStatuses[node.NodeKey()]</span>
}

// FindMasterNode 查找主节点
func (t *ClusterTopology) FindMasterNode() *NodeConfig <span class="cov8" title="1">{
        return t.MasterNode
}</span>

// GetSlaveNodes 获取所有从节点
func (t *ClusterTopology) GetSlaveNodes() []*NodeConfig <span class="cov8" title="1">{
        return t.SlaveNodes
}</span>

// GetDownstreamNodes 获取指定节点的下游节点
func (t *ClusterTopology) GetDownstreamNodes(node *NodeConfig) []*NodeConfig <span class="cov8" title="1">{
        key := node.NodeKey()
        downstreams, exists := t.Relationships[key]
        if !exists </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov8" title="1">var nodes []*NodeConfig
        for _, downstream := range downstreams </span><span class="cov8" title="1">{
                for _, slave := range t.SlaveNodes </span><span class="cov8" title="1">{
                        if slave.NodeKey() == downstream </span><span class="cov8" title="1">{
                                nodes = append(nodes, slave)
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">return nodes</span>
}</pre>
		
		<pre class="file" id="file5" style="display: none">package cmd

import (
        "context"
        "fmt"
        "os"
        "strconv"
        "strings"
        "text/tabwriter"
        "time"

        "mysql_tablespace_recycling/recycler"

        "github.com/spf13/cobra"
)

// 分析命令选项
var (
        analyzeOutput     string
        analyzeThreshold  string
        analyzeDatabases  []string
        analyzeExcludeDB  []string
        analyzeTables     []string
        analyzeEngines    []string
        analyzeSortBy     string
        analyzeSortOrder  string
        analyzeLimit      int
        analyzeMinSize    string
        analyzeMaxSize    string
)

var analyzeCmd = &amp;cobra.Command{
        Use:   "analyze",
        Short: "分析表空间碎片",
        Long: `分析指定MySQL实例的表空间碎片情况。

该命令会扫描数据库中的所有表，分析其碎片化程度，并生成详细的分析报告。
支持多种过滤和排序选项，帮助识别需要优化的表。`,
        Example: `  # 分析本地MySQL实例
  mysql-recycler analyze

  # 分析特定主机的碎片，输出JSON格式
  mysql-recycler analyze --host=192.168.1.100 --output=json

  # 只分析特定数据库，碎片阈值100MB
  mysql-recycler analyze --database=myapp --threshold=100MB

  # 排除系统数据库，按碎片大小排序，限制前10个
  mysql-recycler analyze --exclude-db=mysql,information_schema,performance_schema --sort-by=fragment_size --limit=10`,
        RunE: runAnalyze,
}

func init() <span class="cov0" title="0">{
        analyzeCmd.Flags().StringVarP(&amp;analyzeOutput, "output", "o", "table", "输出格式 (table, json)")
        analyzeCmd.Flags().StringVar(&amp;analyzeThreshold, "threshold", "50MB", "碎片大小阈值")
        analyzeCmd.Flags().StringSliceVar(&amp;analyzeDatabases, "database", nil, "指定数据库 (可多次使用)")
        analyzeCmd.Flags().StringSliceVar(&amp;analyzeExcludeDB, "exclude-db", []string{"information_schema", "performance_schema", "mysql", "sys"}, "排除数据库")
        analyzeCmd.Flags().StringSliceVar(&amp;analyzeTables, "table", nil, "指定表名 (支持通配符)")
        analyzeCmd.Flags().StringSliceVar(&amp;analyzeEngines, "engine", []string{"InnoDB"}, "存储引擎")
        analyzeCmd.Flags().StringVar(&amp;analyzeSortBy, "sort-by", "fragment_size", "排序字段 (fragment_size, fragment_ratio, total_size, table_name)")
        analyzeCmd.Flags().StringVar(&amp;analyzeSortOrder, "sort-order", "desc", "排序顺序 (asc, desc)")
        analyzeCmd.Flags().IntVar(&amp;analyzeLimit, "limit", 0, "限制结果数量 (0表示无限制)")
        analyzeCmd.Flags().StringVar(&amp;analyzeMinSize, "min-size", "10MB", "表最小大小")
        analyzeCmd.Flags().StringVar(&amp;analyzeMaxSize, "max-size", "", "表最大大小")
}</span>

func runAnalyze(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // 创建节点配置
        nodeConfig, err := createNodeConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create node config: %w", err)
        }</span>

        // 解析阈值
        <span class="cov0" title="0">thresholdBytes, err := parseSize(analyzeThreshold)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid threshold: %w", err)
        }</span>

        <span class="cov0" title="0">minSizeBytes, err := parseSize(analyzeMinSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid min-size: %w", err)
        }</span>

        <span class="cov0" title="0">var maxSizeBytes int64
        if analyzeMaxSize != "" </span><span class="cov0" title="0">{
                maxSizeBytes, err = parseSize(analyzeMaxSize)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid max-size: %w", err)
                }</span>
        }

        // 创建分析选项
        <span class="cov0" title="0">options := &amp;recycler.FragmentationAnalysisOptions{
                MinFragmentSize:  thresholdBytes,
                MinFragmentRatio: 0.01, // 1%最小碎片率
                MinTableSize:     minSizeBytes,
                MaxTableSize:     maxSizeBytes,
                IncludeSchemas:   analyzeDatabases,
                ExcludeSchemas:   analyzeExcludeDB,
                SupportedEngines: analyzeEngines,
                SortBy:           analyzeSortBy,
                SortOrder:        analyzeSortOrder,
                Limit:            analyzeLimit,
        }

        // 创建分析器
        factory := &amp;ConnectionFactory{}
        analyzer := recycler.NewFragmentationAnalyzer(factory)

        // 执行分析
        ctx, cancel := context.WithTimeout(context.Background(), 5*time.Minute)
        defer cancel()

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("正在分析 %s 的表空间碎片...\n", nodeConfig.NodeKey())
        }</span>

        <span class="cov0" title="0">report, err := analyzer.AnalyzeFragmentation(ctx, nodeConfig, options)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("analysis failed: %w", err)
        }</span>

        // 输出结果
        <span class="cov0" title="0">switch analyzeOutput </span>{
        case "json":<span class="cov0" title="0">
                return printJSON(report)</span>
        case "table":<span class="cov0" title="0">
                return printAnalysisReport(report)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s", analyzeOutput)</span>
        }
}

// parseSize 解析大小字符串
func parseSize(sizeStr string) (int64, error) <span class="cov0" title="0">{
        if sizeStr == "" </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">sizeStr = strings.TrimSpace(strings.ToUpper(sizeStr))
        
        var multiplier int64 = 1
        var numStr string

        if strings.HasSuffix(sizeStr, "GB") </span><span class="cov0" title="0">{
                multiplier = 1024 * 1024 * 1024
                numStr = strings.TrimSuffix(sizeStr, "GB")
        }</span> else<span class="cov0" title="0"> if strings.HasSuffix(sizeStr, "MB") </span><span class="cov0" title="0">{
                multiplier = 1024 * 1024
                numStr = strings.TrimSuffix(sizeStr, "MB")
        }</span> else<span class="cov0" title="0"> if strings.HasSuffix(sizeStr, "KB") </span><span class="cov0" title="0">{
                multiplier = 1024
                numStr = strings.TrimSuffix(sizeStr, "KB")
        }</span> else<span class="cov0" title="0"> if strings.HasSuffix(sizeStr, "B") </span><span class="cov0" title="0">{
                multiplier = 1
                numStr = strings.TrimSuffix(sizeStr, "B")
        }</span> else<span class="cov0" title="0"> {
                // 默认为字节
                numStr = sizeStr
        }</span>

        <span class="cov0" title="0">num, err := strconv.ParseFloat(strings.TrimSpace(numStr), 64)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid size format: %s", sizeStr)
        }</span>

        <span class="cov0" title="0">return int64(num * float64(multiplier)), nil</span>
}

// printAnalysisReport 打印分析报告
func printAnalysisReport(report *recycler.FragmentationReport) error <span class="cov0" title="0">{
        // 打印摘要
        fmt.Printf("MySQL表空间碎片分析报告\n")
        fmt.Printf("==============================\n")
        fmt.Printf("节点: %s:%d\n", report.NodeHost, report.NodePort)
        fmt.Printf("分析时间: %s\n", report.AnalysisTime.Format("2006-01-02 15:04:05"))
        fmt.Printf("总表数: %d\n", report.TotalTables)
        fmt.Printf("碎片化表数: %d\n", len(report.FragmentedTables))
        fmt.Printf("总数据大小: %s\n", formatBytes(report.TotalDataSize))
        fmt.Printf("总索引大小: %s\n", formatBytes(report.TotalIndexSize))
        fmt.Printf("总碎片大小: %s\n", formatBytes(report.TotalFragmentSize))
        fmt.Printf("预计可回收空间: %s\n", formatBytes(report.EstimatedReclaimableSpace))
        
        if report.AverageFragmentRatio &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("平均碎片率: %.2f%%\n", report.AverageFragmentRatio*100)
        }</span>
        
        <span class="cov0" title="0">fmt.Println()

        // 如果没有碎片化表，直接返回
        if len(report.FragmentedTables) == 0 </span><span class="cov0" title="0">{
                fmt.Println("未发现碎片化表，数据库已优化")
                return nil
        }</span>

        // 打印碎片化表详情
        <span class="cov0" title="0">fmt.Printf("碎片化表详情:\n")
        fmt.Printf("============\n")

        w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
        fmt.Fprintln(w, "数据库\t表名\t存储引擎\t表大小\t碎片大小\t碎片率\t严重程度\t预估回收时间")
        fmt.Fprintln(w, "------\t----\t--------\t------\t--------\t------\t--------\t-----------")

        factory := &amp;ConnectionFactory{}
        analyzer := recycler.NewFragmentationAnalyzer(factory)

        for i, table := range report.FragmentedTables </span><span class="cov0" title="0">{
                benefit, _ := analyzer.EstimateReclaimBenefit(table)
                estimatedTime := "未知"
                if benefit != nil </span><span class="cov0" title="0">{
                        estimatedTime = formatDuration(benefit.EstimatedTimeCost)
                }</span>

                <span class="cov0" title="0">fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\t%.2f%%\t%s\t%s\n",
                        table.Schema,
                        table.TableName,
                        table.Engine,
                        formatBytes(table.TotalSize),
                        formatBytes(table.DataFree),
                        table.FragmentRatio*100,
                        getSeverityDisplay(table.GetFragmentationSeverity()),
                        estimatedTime,
                )

                // 限制显示数量，避免输出过长
                if i &gt;= 19 &amp;&amp; len(report.FragmentedTables) &gt; 20 </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "...\t...\t...\t...\t...\t...\t...\t...\n")
                        fmt.Fprintf(w, "(%d more tables)\t\t\t\t\t\t\t\n", len(report.FragmentedTables)-20)
                        break</span>
                }
        }
        <span class="cov0" title="0">w.Flush()

        // 显示最大碎片表
        if report.LargestFragmentTable != nil </span><span class="cov0" title="0">{
                fmt.Printf("\n最大碎片表: %s.%s (%s)\n", 
                        report.LargestFragmentTable.Schema,
                        report.LargestFragmentTable.TableName,
                        formatBytes(report.LargestFragmentTable.DataFree))
        }</span>

        // 显示最高碎片率表
        <span class="cov0" title="0">if report.HighestRatioTable != nil </span><span class="cov0" title="0">{
                fmt.Printf("最高碎片率表: %s.%s (%.2f%%)\n", 
                        report.HighestRatioTable.Schema,
                        report.HighestRatioTable.TableName,
                        report.HighestRatioTable.FragmentRatio*100)
        }</span>

        // 显示建议
        <span class="cov0" title="0">if len(report.RecommendedActions) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n优化建议:\n")
                fmt.Printf("========\n")
                for i, action := range report.RecommendedActions </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s\n", i+1, action)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// getSeverityDisplay 获取严重程度的显示文本
func getSeverityDisplay(severity string) string <span class="cov0" title="0">{
        switch severity </span>{
        case "severe":<span class="cov0" title="0">
                return "严重"</span>
        case "moderate":<span class="cov0" title="0">
                return "中等"</span>
        case "mild":<span class="cov0" title="0">
                return "轻微"</span>
        case "minimal":<span class="cov0" title="0">
                return "微小"</span>
        default:<span class="cov0" title="0">
                return severity</span>
        }
}</pre>
		
		<pre class="file" id="file6" style="display: none">package cmd

import (
        "context"
        "fmt"
        "os"
        "text/tabwriter"
        "time"

        "mysql_tablespace_recycling/cluster"
        "mysql_tablespace_recycling/monitor"
        "mysql_tablespace_recycling/recycler"

        "github.com/spf13/cobra"
)

// 回收命令选项
var (
        reclaimMode        int
        reclaimThreshold   string
        reclaimConcurrency int
        reclaimDryRun      bool
        reclaimAllowMaster bool
        reclaimForce       bool
        reclaimDatabases   []string
        reclaimExcludeDB   []string
        reclaimTables      []string
        reclaimMinSize     string
        reclaimMaxSize     string
        reclaimOutput      string
        reclaimWatch       bool
)

var reclaimCmd = &amp;cobra.Command{
        Use:   "reclaim",
        Short: "执行表空间碎片回收",
        Long: `在指定的MySQL节点上执行表空间碎片回收操作。

支持两种工作模式：
1. 独立节点模式（默认）：在每个节点独立执行，关闭binlog
2. 复制同步模式：在指定节点执行，通过binlog同步到下游

该命令包含多重安全检查，默认不在主节点执行操作。`,
        Example: `  # 在从节点执行基本回收操作
  mysql-recycler reclaim --host=192.168.1.101

  # 指定模式和参数
  mysql-recycler reclaim \
    --host=192.168.1.101 \
    --mode=1 \
    --threshold=200MB \
    --concurrency=3

  # 模拟运行，查看将要执行的操作
  mysql-recycler reclaim \
    --host=192.168.1.101 \
    --dry-run

  # 强制在主节点执行（谨慎使用）
  mysql-recycler reclaim \
    --host=192.168.1.100 \
    --allow-master

  # 持续监控回收进度
  mysql-recycler reclaim \
    --host=192.168.1.101 \
    --watch`,
        RunE: runReclaim,
}

func init() <span class="cov0" title="0">{
        reclaimCmd.Flags().IntVar(&amp;reclaimMode, "mode", 1, "工作模式 (1=独立节点模式, 2=复制同步模式)")
        reclaimCmd.Flags().StringVar(&amp;reclaimThreshold, "threshold", "100MB", "碎片回收阈值")
        reclaimCmd.Flags().IntVar(&amp;reclaimConcurrency, "concurrency", 3, "并发数")
        reclaimCmd.Flags().BoolVar(&amp;reclaimDryRun, "dry-run", false, "模拟运行，不实际执行")
        reclaimCmd.Flags().BoolVar(&amp;reclaimAllowMaster, "allow-master", false, "允许在主节点执行")
        reclaimCmd.Flags().BoolVar(&amp;reclaimForce, "force", false, "无需确认直接执行回收操作")
        reclaimCmd.Flags().StringSliceVar(&amp;reclaimDatabases, "database", nil, "指定数据库")
        reclaimCmd.Flags().StringSliceVar(&amp;reclaimExcludeDB, "exclude-db", []string{"information_schema", "performance_schema", "mysql", "sys"}, "排除数据库")
        reclaimCmd.Flags().StringSliceVar(&amp;reclaimTables, "table", nil, "指定表名")
        reclaimCmd.Flags().StringVar(&amp;reclaimMinSize, "min-size", "10MB", "表最小大小")
        reclaimCmd.Flags().StringVar(&amp;reclaimMaxSize, "max-size", "", "表最大大小")
        reclaimCmd.Flags().StringVarP(&amp;reclaimOutput, "output", "o", "table", "输出格式 (table, json)")
        reclaimCmd.Flags().BoolVar(&amp;reclaimWatch, "watch", false, "持续监控进度")

        // 添加到根命令
        RootCmd.AddCommand(reclaimCmd)
}</span>

func runReclaim(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // 创建节点配置
        nodeConfig, err := createNodeConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create node config: %w", err)
        }</span>

        // 解析参数
        <span class="cov0" title="0">thresholdBytes, err := parseSize(reclaimThreshold)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid threshold: %w", err)
        }</span>

        <span class="cov0" title="0">minSizeBytes, err := parseSize(reclaimMinSize)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid min-size: %w", err)
        }</span>

        <span class="cov0" title="0">var maxSizeBytes int64
        if reclaimMaxSize != "" </span><span class="cov0" title="0">{
                maxSizeBytes, err = parseSize(reclaimMaxSize)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid max-size: %w", err)
                }</span>
        }

        // 创建组件
        <span class="cov0" title="0">factory := &amp;ConnectionFactory{}
        analyzer := recycler.NewFragmentationAnalyzer(factory)

        // 创建主节点验证器
        clusterFactory := &amp;cluster.DefaultConnectionFactory{}
        discoverer := cluster.NewTopologyDiscoverer(clusterFactory, &amp;cluster.DiscoveryOptions{
                MaxConcurrency: 3,
                Timeout:        30 * time.Second,
                MaxDepth:       1,
        })
        validator := cluster.NewMasterValidator(discoverer, nil, clusterFactory, false)

        // 创建回收器
        recyclerInstance := recycler.NewTablespaceRecycler(factory, analyzer, &amp;MasterValidatorAdapter{validator})

        // 创建监控器
        monitorConfig := &amp;monitor.MonitorConfig{
                StatusFile:        "/tmp/mysql-recycler-status.json",
                MaxHistoryRecords: 100,
                PersistInterval:   30 * time.Second,
                EnableAutoSave:    true,
        }
        monitorInstance := monitor.NewMonitor(monitorConfig)
        defer monitorInstance.Shutdown()

        // 注册通知钩子
        notificationHook := monitor.NewNotificationHook("")
        monitorInstance.RegisterHook(notificationHook)

        // 首先分析表空间碎片
        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("正在分析 %s 的表空间碎片...\n", nodeConfig.NodeKey())
        }</span>

        <span class="cov0" title="0">analysisOptions := &amp;recycler.FragmentationAnalysisOptions{
                MinFragmentSize:  thresholdBytes,
                MinFragmentRatio: 0.01,
                MinTableSize:     minSizeBytes,
                MaxTableSize:     maxSizeBytes,
                IncludeSchemas:   reclaimDatabases,
                ExcludeSchemas:   reclaimExcludeDB,
                SupportedEngines: []string{"InnoDB"},
                SortBy:           "fragment_size",
                SortOrder:        "desc",
        }

        ctx, cancel := context.WithTimeout(context.Background(), 10*time.Minute)
        defer cancel()

        report, err := analyzer.AnalyzeFragmentation(ctx, nodeConfig, analysisOptions)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("fragmentation analysis failed: %w", err)
        }</span>

        <span class="cov0" title="0">if len(report.FragmentedTables) == 0 </span><span class="cov0" title="0">{
                fmt.Println("未发现需要回收的碎片化表")
                return nil
        }</span>

        // 显示分析结果
        <span class="cov0" title="0">fmt.Printf("发现 %d 个碎片化表，预计可回收 %s 空间\n",
                len(report.FragmentedTables),
                formatBytes(report.EstimatedReclaimableSpace))

        // 创建回收任务
        taskID := fmt.Sprintf("reclaim-%d", time.Now().Unix())
        
        // 获取超时配置
        timeoutConfig, err := createTimeoutConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create timeout config: %w", err)
        }</span>
        
        // 转换 nodeConfig 类型并包含超时配置
        <span class="cov0" title="0">clusterNodeConfig := &amp;cluster.NodeConfig{
                Host:     nodeConfig.Host,
                Port:     nodeConfig.Port,
                Username: nodeConfig.Username,
                Password: nodeConfig.Password,
                Database: nodeConfig.Database,
                Timeout:  nodeConfig.Timeout,
                
                // 设置新的超时配置
                ConnectTimeout:   timeoutConfig.Connect,
                QueryTimeout:     timeoutConfig.Query,
                AlterTimeout:     timeoutConfig.Alter,
                DiscoveryTimeout: timeoutConfig.Discovery,
        }
        
        task := &amp;recycler.RecycleTask{
                ID:        taskID,
                CreatedAt: time.Now(),
                Status:    recycler.StatusPending,
                Target: &amp;recycler.RecycleTarget{
                        Node:         clusterNodeConfig,
                        Mode:         recycler.RecycleMode(reclaimMode),
                        Threshold:    thresholdBytes,
                        Concurrency:  reclaimConcurrency,
                        DryRun:       reclaimDryRun,
                        SafetyChecks: !reclaimAllowMaster,
                },
                Tables: report.FragmentedTables,
        }

        // 显示即将执行的操作
        if err := printReclaimPlan(task); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // 确认执行
        <span class="cov0" title="0">if !reclaimDryRun </span><span class="cov0" title="0">{
                fmt.Print("\n是否继续执行回收操作？(y/N): ")
                var response string
                if !reclaimForce </span><span class="cov0" title="0">{
                        fmt.Scanln(&amp;response)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Println("Y（强制回收无需确认）")
                        response = "y"
                }</span>
                <span class="cov0" title="0">if response != "y" &amp;&amp; response != "Y" </span><span class="cov0" title="0">{
                        fmt.Println("操作已取消")
                        return nil
                }</span>
        }

        // 开始监控任务
        <span class="cov0" title="0">if err := monitorInstance.StartTask(task); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to start monitoring: %w", err)
        }</span>

        // 注册进度回调
        <span class="cov0" title="0">if progressRecycler, ok := recyclerInstance.(*recycler.DefaultTablespaceRecycler); ok </span><span class="cov0" title="0">{
                progressRecycler.RegisterProgressCallback(func(progress *recycler.TaskProgress) </span><span class="cov0" title="0">{
                        monitorInstance.UpdateProgress(taskID, progress)

                        if reclaimWatch </span><span class="cov0" title="0">{
                                // --watch 模式：显示详细进度
                                printProgress(progress)
                        }</span> else<span class="cov0" title="0"> {
                                // 默认模式：显示简单进度
                                printSimpleProgress(progress)
                        }</span>
                })
        }

        // 执行回收
        <span class="cov0" title="0">fmt.Printf("\n开始执行表空间回收 (任务ID: %s)...\n", taskID)
        
        // 通知监控器任务开始运行
        if err := monitorInstance.UpdateTaskStatus(taskID, recycler.StatusRunning); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: failed to update task status: %v\n", err)
        }</span>
        
        <span class="cov0" title="0">result, err := recyclerInstance.ExecuteRecycle(ctx, task)

        // 完成监控
        if monitorErr := monitorInstance.CompleteTask(taskID, result, err); monitorErr != nil </span><span class="cov0" title="0">{
                fmt.Printf("Warning: failed to complete task monitoring: %v\n", monitorErr)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("reclaim failed: %w", err)
        }</span>

        // 显示结果
        <span class="cov0" title="0">return printReclaimResult(result)</span>
}

// printReclaimPlan 打印回收计划
func printReclaimPlan(task *recycler.RecycleTask) error <span class="cov0" title="0">{
        fmt.Printf("\n回收计划:\n")
        fmt.Printf("========\n")
        fmt.Printf("任务ID: %s\n", task.ID)
        fmt.Printf("目标节点: %s\n", task.Target.Node.NodeKey())

        modeDesc := "独立节点模式 (sql_log_bin=OFF)"
        if task.Target.Mode == recycler.ModeReplication </span><span class="cov0" title="0">{
                modeDesc = "复制同步模式 (sql_log_bin=ON)"
        }</span>
        <span class="cov0" title="0">fmt.Printf("工作模式: %s\n", modeDesc)
        fmt.Printf("并发数: %d\n", task.Target.Concurrency)
        fmt.Printf("碎片阈值: %s\n", formatBytes(task.Target.Threshold))

        if task.Target.DryRun </span><span class="cov0" title="0">{
                fmt.Printf("运行模式: 模拟运行 (不实际执行)\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("运行模式: 实际执行\n")
        }</span>

        <span class="cov0" title="0">fmt.Printf("待处理表数: %d\n", len(task.Tables))

        // 显示前几个表的详情
        fmt.Printf("\n待处理表 (前10个):\n")
        w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
        fmt.Fprintln(w, "数据库\t表名\t表大小\t碎片大小\t碎片率\t预估时间")
        fmt.Fprintln(w, "------\t----\t------\t--------\t------\t--------")

        count := 0
        for _, table := range task.Tables </span><span class="cov0" title="0">{
                if count &gt;= 10 </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "...\t...\t...\t...\t...\t...\n")
                        fmt.Fprintf(w, "还有%d个表\t\t\t\t\t\n", len(task.Tables)-10)
                        break</span>
                }

                // 估算单表处理时间
                <span class="cov0" title="0">estimatedTime := estimateTableReclaimTime(table)

                fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%.2f%%\t%s\n",
                        table.Schema,
                        table.TableName,
                        formatBytes(table.TotalSize),
                        formatBytes(table.DataFree),
                        table.FragmentRatio*100,
                        formatDuration(estimatedTime),
                )
                count++</span>
        }
        <span class="cov0" title="0">w.Flush()

        return nil</span>
}

// printProgress 打印进度信息
func printProgress(progress *recycler.TaskProgress) <span class="cov0" title="0">{
        fmt.Printf("\r进度: %d/%d 表 (%.1f%%) | 当前: %s | 已回收: %s | 预计剩余: %s",
                progress.CompletedTables,
                progress.TotalTables,
                float64(progress.CompletedTables)/float64(progress.TotalTables)*100,
                progress.CurrentTable,
                formatBytes(progress.ReclaimedSpace),
                formatDuration(progress.EstimatedRemaining),
        )
}</span>

// printSimpleProgress 打印简单进度信息
func printSimpleProgress(progress *recycler.TaskProgress) <span class="cov0" title="0">{
        // 只在任务开始和表完成时打印
        if progress.CompletedTables == 0 &amp;&amp; progress.CurrentTable != "" </span><span class="cov0" title="0">{
                // 任务开始
                fmt.Printf("开始处理: %s (%d/%d)\n", progress.CurrentTable, progress.CompletedTables+1, progress.TotalTables)
        }</span> else<span class="cov0" title="0"> if progress.CompletedTables &gt; 0 </span><span class="cov0" title="0">{
                // 表完成，显示进度更新
                percentage := float64(progress.CompletedTables) / float64(progress.TotalTables) * 100
                fmt.Printf("已完成: %d/%d 表 (%.1f%%) | 已回收: %s\n", 
                        progress.CompletedTables, 
                        progress.TotalTables, 
                        percentage,
                        formatBytes(progress.ReclaimedSpace))
        }</span>
}

// printReclaimResult 打印回收结果
func printReclaimResult(result *recycler.RecycleResult) error <span class="cov0" title="0">{
        fmt.Printf("\n回收完成!\n")
        fmt.Printf("==========\n")
        fmt.Printf("任务ID: %s\n", result.TaskID)
        fmt.Printf("处理时间: %s\n", formatDuration(result.TotalTime))
        fmt.Printf("处理表数: %d\n", result.ProcessedTables)
        fmt.Printf("成功: %d, 失败: %d, 跳过: %d\n",
                result.SuccessfulTables, result.FailedTables, result.SkippedTables)
        fmt.Printf("回收空间: %s\n", formatBytes(result.ReclaimedSpace))

        if result.SuccessfulTables &gt; 0 </span><span class="cov0" title="0">{
                avgTime := result.TotalTime / time.Duration(result.SuccessfulTables)
                fmt.Printf("平均每表用时: %s\n", formatDuration(avgTime))
        }</span>

        // 显示错误和警告
        <span class="cov0" title="0">if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n错误信息:\n")
                for i, err := range result.Errors </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s\n", i+1, err)
                }</span>
        }

        <span class="cov0" title="0">if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n警告信息:\n")
                for i, warning := range result.Warnings </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s\n", i+1, warning)
                }</span>
        }

        // 详细的表处理结果
        <span class="cov0" title="0">if len(result.TableResults) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n详细结果:\n")
                w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
                fmt.Fprintln(w, "数据库\t表名\t状态\t回收空间\t用时\t备注")
                fmt.Fprintln(w, "------\t----\t----\t--------\t----\t----")

                for _, tr := range result.TableResults </span><span class="cov0" title="0">{
                        status := "✓"
                        if tr.Status == "failed" </span><span class="cov0" title="0">{
                                status = "✗"
                        }</span> else<span class="cov0" title="0"> if tr.Status == "dry_run" </span><span class="cov0" title="0">{
                                status = "○"
                        }</span>

                        <span class="cov0" title="0">note := ""
                        if tr.Error != "" </span><span class="cov0" title="0">{
                                note = tr.Error
                                if len(note) &gt; 30 </span><span class="cov0" title="0">{
                                        note = note[:30] + "..."
                                }</span>
                        }

                        <span class="cov0" title="0">fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\t%s\n",
                                tr.Schema,
                                tr.TableName,
                                status,
                                formatBytes(tr.ReclaimedSpace),
                                formatDuration(tr.Duration),
                                note,
                        )</span>
                }
                <span class="cov0" title="0">w.Flush()</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// estimateTableReclaimTime 估算单个表的回收时间
func estimateTableReclaimTime(table *recycler.TableFragmentation) time.Duration <span class="cov0" title="0">{
        // 基于表大小的简单估算：每GB约需2分钟
        sizeMB := float64(table.TotalSize) / (1024 * 1024)
        estimatedMinutes := sizeMB / 1024 * 2 // 每GB 2分钟

        // 最少30秒，最多30分钟
        if estimatedMinutes &lt; 0.5 </span><span class="cov0" title="0">{
                estimatedMinutes = 0.5
        }</span> else<span class="cov0" title="0"> if estimatedMinutes &gt; 30 </span><span class="cov0" title="0">{
                estimatedMinutes = 30
        }</span>

        <span class="cov0" title="0">return time.Duration(estimatedMinutes * float64(time.Minute))</span>
}

// MasterValidatorAdapter 适配器
type MasterValidatorAdapter struct {
        validator cluster.MasterValidator
}

func (a *MasterValidatorAdapter) ValidateMasterSafety(ctx context.Context, node recycler.NodeConfigInterface) error <span class="cov0" title="0">{
        clusterNode := &amp;cluster.NodeConfig{
                Host:     node.GetHost(),
                Port:     node.GetPort(),
                Username: node.GetUsername(),
                Password: node.GetPassword(),
                Database: node.GetDatabase(),
                Timeout:  node.GetTimeout(),
        }

        return a.validator.ValidateMasterSafety(ctx, clusterNode)
}</span>
</pre>
		
		<pre class="file" id="file7" style="display: none">package cmd

import (
        "encoding/json"
        "fmt"
        "os"
        "time"

        "mysql_tablespace_recycling/cluster"
        "mysql_tablespace_recycling/config"
        "mysql_tablespace_recycling/pkg/logger"
        "mysql_tablespace_recycling/recycler"

        "github.com/spf13/cobra"
)

// RootCmd 根命令
var RootCmd = &amp;cobra.Command{
        Use:   "mysql-recycler",
        Short: "MySQL表空间碎片回收工具",
        Long: `MySQL表空间碎片回收工具
一个基于测试驱动开发的高性能MySQL表空间碎片回收工具，支持集群拓扑感知和安全的并发操作。`,
        PersistentPreRun: initializeLogger,
}

var appConfig *config.Config

// 全局选项
var (
        cfgFile     string
        logLevel    string
        logFormat   string
        verbose     bool
)

// 数据库连接选项
var (
        dbHost     string
        dbPort     int
        dbUser     string
        dbPassword string
        dbDatabase string
        dbTimeout  string
)

// 超时配置选项
var (
        connectTimeout   string  // 数据库连接超时
        queryTimeout     string  // 查询超时
        alterTimeout     string  // ALTER TABLE操作超时
        discoveryTimeout string  // 集群发现超时
)

func init() <span class="cov0" title="0">{
        // 全局标志
        RootCmd.PersistentFlags().StringVar(&amp;cfgFile, "config", "", "配置文件路径 (默认是 $HOME/.mysql-recycler.yaml)")
        RootCmd.PersistentFlags().StringVar(&amp;logLevel, "log-level", "info", "日志级别 (debug, info, warn, error)")
        RootCmd.PersistentFlags().StringVar(&amp;logFormat, "log-format", "text", "日志格式 (text, json)")
        RootCmd.PersistentFlags().BoolVarP(&amp;verbose, "verbose", "v", false, "详细输出")

        // 数据库连接标志
        RootCmd.PersistentFlags().StringVarP(&amp;dbHost, "host", "H", "localhost", "MySQL主机地址")
        RootCmd.PersistentFlags().IntVarP(&amp;dbPort, "port", "P", 3306, "MySQL端口")
        RootCmd.PersistentFlags().StringVarP(&amp;dbUser, "user", "u", "root", "MySQL用户名")
        RootCmd.PersistentFlags().StringVarP(&amp;dbPassword, "password", "p", "", "MySQL密码")
        RootCmd.PersistentFlags().StringVarP(&amp;dbDatabase, "database", "d", "information_schema", "数据库名")
        RootCmd.PersistentFlags().StringVar(&amp;dbTimeout, "timeout", "30s", "连接超时时间")

        // 超时配置标志
        RootCmd.PersistentFlags().StringVar(&amp;connectTimeout, "connect-timeout", "30s", "数据库连接超时时间")
        RootCmd.PersistentFlags().StringVar(&amp;queryTimeout, "query-timeout", "300s", "普通查询超时时间")
        RootCmd.PersistentFlags().StringVar(&amp;alterTimeout, "alter-timeout", "3600s", "ALTER TABLE操作超时时间")
        RootCmd.PersistentFlags().StringVar(&amp;discoveryTimeout, "discovery-timeout", "120s", "集群发现超时时间")

        // 添加子命令
        RootCmd.AddCommand(analyzeCmd)
        RootCmd.AddCommand(topologyCmd)
        RootCmd.AddCommand(validateCmd)
}</span>

// initializeLogger 初始化日志系统
func initializeLogger(cmd *cobra.Command, args []string) <span class="cov0" title="0">{
        // 加载配置文件
        var err error
        if cfgFile == "" </span><span class="cov0" title="0">{
                cfgFile = config.FindConfigFile()
        }</span>
        <span class="cov0" title="0">appConfig, err = config.LoadConfig(cfgFile)
        if err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Warning: failed to load config: %v\n", err)
                appConfig = config.GetDefaultConfig()
        }</span>
        
        // 从环境变量加载配置
        <span class="cov0" title="0">config.LoadConfigFromEnv(appConfig)
        
        // 初始化日志系统
        logLevelToUse := logLevel
        if verbose </span><span class="cov0" title="0">{
                logLevelToUse = "debug"
        }</span>
        
        // 如果有配置文件，使用配置文件中的日志设置
        <span class="cov0" title="0">if appConfig != nil &amp;&amp; logLevel == "info" </span><span class="cov0" title="0">{ // 只有在用户没有明确指定时才使用配置文件
                logLevelToUse = appConfig.Logging.Level
        }</span>
        
        <span class="cov0" title="0">var output *os.File
        if appConfig != nil &amp;&amp; appConfig.Logging.OutputFile != "" </span><span class="cov0" title="0">{
                output, err = os.OpenFile(appConfig.Logging.OutputFile, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0644)
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Fprintf(os.Stderr, "Warning: failed to open log file %s: %v\n", appConfig.Logging.OutputFile, err)
                        output = nil
                }</span>
        }
        
        <span class="cov0" title="0">if output == nil </span><span class="cov0" title="0">{
                output = os.Stdout
        }</span>
        
        <span class="cov0" title="0">globalLogger := logger.NewLoggerFromString(logLevelToUse, output)
        logger.SetGlobalLogger(globalLogger)
        
        if verbose || logLevelToUse == "debug" </span><span class="cov0" title="0">{
                logger.Debug("日志系统已初始化，级别: %s", logLevelToUse)
        }</span>
}

// Execute 执行命令
func Execute() <span class="cov0" title="0">{
        if err := RootCmd.Execute(); err != nil </span><span class="cov0" title="0">{
                fmt.Fprintf(os.Stderr, "Error: %v\n", err)
                os.Exit(1)
        }</span>
}

// TimeoutConfig 超时配置
type TimeoutConfig struct {
        Connect   time.Duration // 连接超时
        Query     time.Duration // 查询超时
        Alter     time.Duration // ALTER TABLE超时
        Discovery time.Duration // 集群发现超时
}

// createTimeoutConfig 创建超时配置
func createTimeoutConfig() (*TimeoutConfig, error) <span class="cov0" title="0">{
        connectTimeout, err := time.ParseDuration(connectTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid connect-timeout format: %w", err)
        }</span>

        <span class="cov0" title="0">queryTimeout, err := time.ParseDuration(queryTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid query-timeout format: %w", err)
        }</span>

        <span class="cov0" title="0">alterTimeout, err := time.ParseDuration(alterTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid alter-timeout format: %w", err)
        }</span>

        <span class="cov0" title="0">discoveryTimeout, err := time.ParseDuration(discoveryTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid discovery-timeout format: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;TimeoutConfig{
                Connect:   connectTimeout,
                Query:     queryTimeout,
                Alter:     alterTimeout,
                Discovery: discoveryTimeout,
        }, nil</span>
}

// createNodeConfig 创建节点配置
func createNodeConfig() (*NodeConfig, error) <span class="cov0" title="0">{
        timeout, err := time.ParseDuration(dbTimeout)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid timeout format: %w", err)
        }</span>

        <span class="cov0" title="0">return &amp;NodeConfig{
                Host:     dbHost,
                Port:     dbPort,
                Username: dbUser,
                Password: dbPassword,
                Database: dbDatabase,
                Timeout:  timeout,
        }, nil</span>
}

// NodeConfig 适配器，实现recycler.NodeConfigInterface
type NodeConfig struct {
        Host     string
        Port     int
        Username string
        Password string
        Database string
        Timeout  time.Duration
}

func (n *NodeConfig) GetHost() string           <span class="cov0" title="0">{ return n.Host }</span>
func (n *NodeConfig) GetPort() int              <span class="cov0" title="0">{ return n.Port }</span>
func (n *NodeConfig) GetUsername() string       <span class="cov0" title="0">{ return n.Username }</span>
func (n *NodeConfig) GetPassword() string       <span class="cov0" title="0">{ return n.Password }</span>
func (n *NodeConfig) GetDatabase() string       <span class="cov0" title="0">{ return n.Database }</span>
func (n *NodeConfig) GetTimeout() time.Duration <span class="cov0" title="0">{ return n.Timeout }</span>
func (n *NodeConfig) NodeKey() string           <span class="cov0" title="0">{ return fmt.Sprintf("%s:%d", n.Host, n.Port) }</span>
func (n *NodeConfig) IsValid() bool            <span class="cov0" title="0">{ return n.Host != "" &amp;&amp; n.Port &gt; 0 &amp;&amp; n.Username != "" }</span>

// toClusterNodeConfig 转换为cluster包的NodeConfig
func (n *NodeConfig) toClusterNodeConfig() *cluster.NodeConfig <span class="cov0" title="0">{
        return &amp;cluster.NodeConfig{
                Host:     n.Host,
                Port:     n.Port,
                Username: n.Username,
                Password: n.Password,
                Database: n.Database,
                Timeout:  n.Timeout,
        }
}</span>

// ConnectionFactory 连接工厂适配器
type ConnectionFactory struct{}

func (f *ConnectionFactory) CreateConnection(config recycler.NodeConfigInterface) (recycler.DBConnection, error) <span class="cov0" title="0">{
        nodeConfig := &amp;cluster.NodeConfig{
                Host:     config.GetHost(),
                Port:     config.GetPort(),
                Username: config.GetUsername(),
                Password: config.GetPassword(),
                Database: config.GetDatabase(),
                Timeout:  config.GetTimeout(),
        }
        
        return cluster.NewMySQLConnection(nodeConfig)
}</span>

// printJSON 以JSON格式输出
func printJSON(data interface{}) error <span class="cov0" title="0">{
        encoder := json.NewEncoder(os.Stdout)
        encoder.SetIndent("", "  ")
        return encoder.Encode(data)
}</span>

// formatBytes 格式化字节数
func formatBytes(bytes int64) string <span class="cov0" title="0">{
        if bytes &lt; 1024 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", bytes)
        }</span> else<span class="cov0" title="0"> if bytes &lt; 1024*1024 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1f KB", float64(bytes)/1024)
        }</span> else<span class="cov0" title="0"> if bytes &lt; 1024*1024*1024 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1f MB", float64(bytes)/(1024*1024))
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%.2f GB", float64(bytes)/(1024*1024*1024))
        }</span>
}

// formatDuration 格式化时间间隔
func formatDuration(d time.Duration) string <span class="cov0" title="0">{
        if d &lt; time.Minute </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.0f秒", d.Seconds())
        }</span> else<span class="cov0" title="0"> if d &lt; time.Hour </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1f分钟", d.Minutes())
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%.1f小时", d.Hours())
        }</span>
}</pre>
		
		<pre class="file" id="file8" style="display: none">package cmd

import (
        "fmt"
        "os"
        "text/tabwriter"
        "time"

        "mysql_tablespace_recycling/monitor"
        "mysql_tablespace_recycling/recycler"

        "github.com/spf13/cobra"
)

// 状态命令选项
var (
        statusTaskID  string
        statusOutput  string
        statusWatch   bool
        statusHistory bool
        statusLimit   int
)

var statusCmd = &amp;cobra.Command{
        Use:   "status",
        Short: "查看任务状态和监控信息",
        Long: `查看MySQL表空间回收任务的状态、进度和监控信息。

可以查看：
- 当前活跃任务的实时状态
- 特定任务的详细信息
- 任务历史记录
- 系统监控统计信息`,
        Example: `  # 查看所有活跃任务
  mysql-recycler status

  # 查看特定任务状态
  mysql-recycler status --task-id=reclaim-1703123456

  # 查看任务历史（最近10个）
  mysql-recycler status --history --limit=10

  # 持续监控模式
  mysql-recycler status --watch

  # 输出JSON格式
  mysql-recycler status --output=json`,
        RunE: runStatus,
}

func init() <span class="cov0" title="0">{
        statusCmd.Flags().StringVar(&amp;statusTaskID, "task-id", "", "特定任务ID")
        statusCmd.Flags().StringVarP(&amp;statusOutput, "output", "o", "table", "输出格式 (table, json)")
        statusCmd.Flags().BoolVar(&amp;statusWatch, "watch", false, "持续监控模式")
        statusCmd.Flags().BoolVar(&amp;statusHistory, "history", false, "显示历史任务")
        statusCmd.Flags().IntVar(&amp;statusLimit, "limit", 20, "限制显示数量")

        // 添加到根命令
        RootCmd.AddCommand(statusCmd)
}</span>

func runStatus(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // 创建监控器来读取状态
        monitorConfig := &amp;monitor.MonitorConfig{
                StatusFile:        "/tmp/mysql-recycler-status.json",
                MaxHistoryRecords: 1000,
        }
        monitorInstance := monitor.NewMonitor(monitorConfig)
        defer monitorInstance.Shutdown()

        // 为status命令加载活跃任务（支持跨进程监控）
        if statusMonitor, ok := monitorInstance.(*monitor.DefaultMonitor); ok </span><span class="cov0" title="0">{
                if err := statusMonitor.LoadActiveTasksForStatus(); err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("Warning: failed to load active tasks: %v\n", err)
                }</span>
        }

        // 持续监控模式
        <span class="cov0" title="0">if statusWatch </span><span class="cov0" title="0">{
                return runWatchMode(monitorInstance)
        }</span>

        // 查看特定任务
        <span class="cov0" title="0">if statusTaskID != "" </span><span class="cov0" title="0">{
                return showTaskStatus(monitorInstance, statusTaskID)
        }</span>

        // 显示历史任务
        <span class="cov0" title="0">if statusHistory </span><span class="cov0" title="0">{
                return showTaskHistory(monitorInstance)
        }</span>

        // 默认显示活跃任务和统计信息
        <span class="cov0" title="0">return showActiveTasksAndStats(monitorInstance)</span>
}

// showActiveTasksAndStats 显示活跃任务和统计信息
func showActiveTasksAndStats(monitorInstance monitor.Monitor) error <span class="cov0" title="0">{
        // 获取活跃任务
        activeTasks, err := monitorInstance.ListActiveTasks()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get active tasks: %w", err)
        }</span>

        // 获取统计信息
        <span class="cov0" title="0">stats := monitorInstance.GetStats()

        if statusOutput == "json" </span><span class="cov0" title="0">{
                data := map[string]interface{}{
                        "active_tasks": activeTasks,
                        "stats":        stats,
                        "timestamp":    time.Now(),
                }
                return printJSON(data)
        }</span>

        // 表格格式输出
        <span class="cov0" title="0">fmt.Printf("MySQL表空间回收工具 - 系统状态\n")
        fmt.Printf("===============================\n")
        fmt.Printf("查询时间: %s\n", time.Now().Format("2006-01-02 15:04:05"))
        fmt.Printf("运行时长: %s\n", formatDuration(time.Since(stats.UptimeStart)))
        fmt.Println()

        // 统计信息
        fmt.Printf("系统统计:\n")
        fmt.Printf("--------\n")
        fmt.Printf("活跃任务: %d\n", stats.ActiveTasks)
        fmt.Printf("已完成任务: %d\n", stats.CompletedTasks)
        fmt.Printf("失败任务: %d\n", stats.FailedTasks)
        fmt.Printf("总回收空间: %s\n", formatBytes(stats.TotalReclaimedSpace))
        fmt.Printf("总处理表数: %d\n", stats.TotalProcessedTables)

        if stats.AverageTaskDuration &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("平均任务时长: %s\n", formatDuration(stats.AverageTaskDuration))
        }</span>

        <span class="cov0" title="0">if !stats.LastPersistTime.IsZero() </span><span class="cov0" title="0">{
                fmt.Printf("上次保存: %s\n", stats.LastPersistTime.Format("2006-01-02 15:04:05"))
        }</span>
        <span class="cov0" title="0">fmt.Println()

        // 活跃任务
        if len(activeTasks) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("当前无活跃任务\n")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("活跃任务 (%d个):\n", len(activeTasks))
        fmt.Printf("===============\n")

        for _, task := range activeTasks </span><span class="cov0" title="0">{
                printTaskSummary(task)
                fmt.Println()
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// showTaskStatus 显示特定任务状态
func showTaskStatus(monitorInstance monitor.Monitor, taskID string) error <span class="cov0" title="0">{
        taskStatus, err := monitorInstance.GetTaskStatus(taskID)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("task not found: %w", err)
        }</span>

        <span class="cov0" title="0">if statusOutput == "json" </span><span class="cov0" title="0">{
                return printJSON(taskStatus)
        }</span>

        // 详细任务信息
        <span class="cov0" title="0">fmt.Printf("任务详细信息\n")
        fmt.Printf("============\n")
        fmt.Printf("任务ID: %s\n", taskStatus.TaskID)
        fmt.Printf("状态: %s\n", getStatusDisplay(taskStatus.Status))
        fmt.Printf("目标节点: %s\n", taskStatus.Target.Node.NodeKey())

        modeDesc := "独立节点模式"
        if taskStatus.Target.Mode == 2 </span><span class="cov0" title="0">{
                modeDesc = "复制同步模式"
        }</span>
        <span class="cov0" title="0">fmt.Printf("工作模式: %s\n", modeDesc)
        fmt.Printf("创建时间: %s\n", taskStatus.CreatedAt.Format("2006-01-02 15:04:05"))

        if taskStatus.StartedAt != nil </span><span class="cov0" title="0">{
                fmt.Printf("开始时间: %s\n", taskStatus.StartedAt.Format("2006-01-02 15:04:05"))
        }</span>

        <span class="cov0" title="0">if taskStatus.CompletedAt != nil </span><span class="cov0" title="0">{
                fmt.Printf("完成时间: %s\n", taskStatus.CompletedAt.Format("2006-01-02 15:04:05"))
                duration := taskStatus.CompletedAt.Sub(*taskStatus.StartedAt)
                fmt.Printf("执行时长: %s\n", formatDuration(duration))
        }</span>

        <span class="cov0" title="0">fmt.Printf("最后更新: %s\n", taskStatus.LastUpdate.Format("2006-01-02 15:04:05"))
        fmt.Println()

        // 进度信息
        if taskStatus.Progress != nil </span><span class="cov0" title="0">{
                fmt.Printf("执行进度:\n")
                fmt.Printf("--------\n")
                progress := taskStatus.Progress
                fmt.Printf("总表数: %d\n", progress.TotalTables)
                fmt.Printf("已完成: %d (%.1f%%)\n",
                        progress.CompletedTables,
                        float64(progress.CompletedTables)/float64(progress.TotalTables)*100)

                if progress.CurrentTable != "" </span><span class="cov0" title="0">{
                        fmt.Printf("当前表: %s\n", progress.CurrentTable)
                }</span>

                <span class="cov0" title="0">fmt.Printf("已处理大小: %s\n", formatBytes(progress.ProcessedSize))
                fmt.Printf("已回收空间: %s\n", formatBytes(progress.ReclaimedSpace))

                if progress.EstimatedRemaining &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("预计剩余时间: %s\n", formatDuration(progress.EstimatedRemaining))
                }</span>

                <span class="cov0" title="0">if progress.ErrorCount &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("错误次数: %d\n", progress.ErrorCount)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // 结果信息
        <span class="cov0" title="0">if taskStatus.Result != nil </span><span class="cov0" title="0">{
                fmt.Printf("执行结果:\n")
                fmt.Printf("--------\n")
                result := taskStatus.Result
                fmt.Printf("处理表数: %d\n", result.ProcessedTables)
                fmt.Printf("成功: %d, 失败: %d, 跳过: %d\n",
                        result.SuccessfulTables, result.FailedTables, result.SkippedTables)
                fmt.Printf("回收空间: %s\n", formatBytes(result.ReclaimedSpace))
                fmt.Printf("总用时: %s\n", formatDuration(result.TotalTime))

                if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("\n错误信息:\n")
                        for i, err := range result.Errors </span><span class="cov0" title="0">{
                                fmt.Printf("%d. %s\n", i+1, err)
                        }</span>
                }

                <span class="cov0" title="0">if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("\n警告信息:\n")
                        for i, warning := range result.Warnings </span><span class="cov0" title="0">{
                                fmt.Printf("%d. %s\n", i+1, warning)
                        }</span>
                }
        }

        // 错误信息
        <span class="cov0" title="0">if taskStatus.ErrorMessage != "" </span><span class="cov0" title="0">{
                fmt.Printf("错误信息: %s\n", taskStatus.ErrorMessage)
        }</span>

        // 警告信息
        <span class="cov0" title="0">if len(taskStatus.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("\n警告信息:\n")
                for i, warning := range taskStatus.Warnings </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s\n", i+1, warning)
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// showTaskHistory 显示任务历史
func showTaskHistory(monitorInstance monitor.Monitor) error <span class="cov0" title="0">{
        history, err := monitorInstance.GetTaskHistory(statusLimit)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to get task history: %w", err)
        }</span>

        <span class="cov0" title="0">if statusOutput == "json" </span><span class="cov0" title="0">{
                return printJSON(history)
        }</span>

        <span class="cov0" title="0">if len(history) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("暂无任务历史记录\n")
                return nil
        }</span>

        <span class="cov0" title="0">fmt.Printf("任务历史记录 (最近%d个):\n", len(history))
        fmt.Printf("========================\n")

        w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
        fmt.Fprintln(w, "任务ID\t状态\t目标节点\t开始时间\t完成时间\t用时\t回收空间")
        fmt.Fprintln(w, "------\t----\t--------\t--------\t--------\t----\t--------")

        for _, task := range history </span><span class="cov0" title="0">{
                startTime := ""
                if task.StartedAt != nil </span><span class="cov0" title="0">{
                        startTime = task.StartedAt.Format("01-02 15:04")
                }</span>

                <span class="cov0" title="0">completedTime := ""
                duration := ""
                if task.CompletedAt != nil </span><span class="cov0" title="0">{
                        completedTime = task.CompletedAt.Format("01-02 15:04")
                        if task.StartedAt != nil </span><span class="cov0" title="0">{
                                duration = formatDuration(task.CompletedAt.Sub(*task.StartedAt))
                        }</span>
                }

                <span class="cov0" title="0">reclaimedSpace := ""
                if task.Result != nil </span><span class="cov0" title="0">{
                        reclaimedSpace = formatBytes(task.Result.ReclaimedSpace)
                }</span>

                // 截断长任务ID
                <span class="cov0" title="0">taskID := task.TaskID
                if len(taskID) &gt; 30 </span><span class="cov0" title="0">{
                        taskID = taskID[:30] + "..."
                }</span>

                <span class="cov0" title="0">fmt.Fprintf(w, "%s\t%s\t%s\t%s\t%s\t%s\t%s\n",
                        taskID,
                        getStatusDisplay(task.Status),
                        task.Target.Node.NodeKey(),
                        startTime,
                        completedTime,
                        duration,
                        reclaimedSpace,
                )</span>
        }
        <span class="cov0" title="0">w.Flush()

        return nil</span>
}

// runWatchMode 运行持续监控模式
func runWatchMode(monitorInstance monitor.Monitor) error <span class="cov0" title="0">{
        fmt.Printf("进入持续监控模式 (按 Ctrl+C 退出)...\n\n")

        for </span><span class="cov0" title="0">{
                // 每次循环重新加载活跃任务以获取最新状态
                if statusMonitor, ok := monitorInstance.(*monitor.DefaultMonitor); ok </span><span class="cov0" title="0">{
                        if err := statusMonitor.LoadActiveTasksForStatus(); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: failed to reload active tasks: %v\n", err)
                        }</span>
                }

                // 清屏
                <span class="cov0" title="0">fmt.Print("\033[2J\033[H")

                // 显示时间戳
                fmt.Printf("MySQL表空间回收工具 - 实时监控\n")
                fmt.Printf("==============================\n")
                fmt.Printf("更新时间: %s\n\n", time.Now().Format("2006-01-02 15:04:05"))

                // 获取并显示活跃任务
                activeTasks, err := monitorInstance.ListActiveTasks()
                if err != nil </span><span class="cov0" title="0">{
                        fmt.Printf("获取任务状态失败: %v\n", err)
                }</span> else<span class="cov0" title="0"> if len(activeTasks) == 0 </span><span class="cov0" title="0">{
                        fmt.Printf("当前无活跃任务\n")
                }</span> else<span class="cov0" title="0"> {
                        for _, task := range activeTasks </span><span class="cov0" title="0">{
                                printTaskProgress(task)
                                fmt.Println()
                        }</span>
                }

                // 显示统计信息
                <span class="cov0" title="0">stats := monitorInstance.GetStats()
                fmt.Printf("统计: 活跃 %d | 完成 %d | 失败 %d | 总回收 %s\n",
                        stats.ActiveTasks,
                        stats.CompletedTasks,
                        stats.FailedTasks,
                        formatBytes(stats.TotalReclaimedSpace))

                // 等待3秒后刷新
                time.Sleep(3 * time.Second)</span>
        }
}

// printTaskSummary 打印任务摘要
func printTaskSummary(task *monitor.TaskStatus) <span class="cov0" title="0">{
        fmt.Printf("任务: %s\n", task.TaskID)
        fmt.Printf("  状态: %s\n", getStatusDisplay(task.Status))
        fmt.Printf("  节点: %s\n", task.Target.Node.NodeKey())

        // 显示任务基本信息
        modeDesc := "独立节点模式"
        if task.Target.Mode == 2 </span><span class="cov0" title="0">{
                modeDesc = "复制同步模式"
        }</span>
        <span class="cov0" title="0">fmt.Printf("  模式: %s\n", modeDesc)
        fmt.Printf("  并发数: %d\n", task.Target.Concurrency)
        fmt.Printf("  阈值: %s\n", formatBytes(task.Target.Threshold))

        if task.StartedAt != nil </span><span class="cov0" title="0">{
                elapsed := time.Since(*task.StartedAt)
                fmt.Printf("  已运行: %s\n", formatDuration(elapsed))
        }</span>

        <span class="cov0" title="0">if task.Progress != nil </span><span class="cov0" title="0">{
                progress := task.Progress
                completionRate := float64(progress.CompletedTables) / float64(progress.TotalTables) * 100
                
                fmt.Printf("  进度: %d/%d (%.1f%%)\n",
                        progress.CompletedTables,
                        progress.TotalTables,
                        completionRate)

                if progress.CurrentTable != "" </span><span class="cov0" title="0">{
                        fmt.Printf("  当前表: %s\n", progress.CurrentTable)
                        if progress.CurrentTableSize &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf("  当前表大小: %s\n", formatBytes(progress.CurrentTableSize))
                        }</span>
                }

                <span class="cov0" title="0">if progress.ProcessedSize &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("  已处理: %s\n", formatBytes(progress.ProcessedSize))
                }</span>

                <span class="cov0" title="0">if progress.ReclaimedSpace &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("  已回收: %s\n", formatBytes(progress.ReclaimedSpace))
                }</span>

                <span class="cov0" title="0">if progress.EstimatedRemaining &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("  预计剩余: %s\n", formatDuration(progress.EstimatedRemaining))
                }</span>

                <span class="cov0" title="0">if progress.ErrorCount &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("  错误次数: %d\n", progress.ErrorCount)
                }</span>

                // 显示处理速度
                <span class="cov0" title="0">if progress.CompletedTables &gt; 0 &amp;&amp; task.StartedAt != nil </span><span class="cov0" title="0">{
                        elapsed := time.Since(*task.StartedAt)
                        avgTimePerTable := elapsed / time.Duration(progress.CompletedTables)
                        fmt.Printf("  平均每表: %s\n", formatDuration(avgTimePerTable))
                }</span>
        }
}

// printTaskProgress 打印任务进度（监控模式）
func printTaskProgress(task *monitor.TaskStatus) <span class="cov0" title="0">{
        fmt.Printf("┌─ 任务: %s\n", task.TaskID)
        fmt.Printf("├─ 节点: %s\n", task.Target.Node.NodeKey())
        fmt.Printf("├─ 状态: %s\n", getStatusDisplay(task.Status))

        // 显示任务配置信息
        modeDesc := "独立节点模式"
        if task.Target.Mode == 2 </span><span class="cov0" title="0">{
                modeDesc = "复制同步模式"
        }</span>
        <span class="cov0" title="0">fmt.Printf("├─ 模式: %s (并发: %d)\n", modeDesc, task.Target.Concurrency)
        fmt.Printf("├─ 阈值: %s\n", formatBytes(task.Target.Threshold))

        // 显示运行时间
        if task.StartedAt != nil </span><span class="cov0" title="0">{
                elapsed := time.Since(*task.StartedAt)
                fmt.Printf("├─ 已运行: %s\n", formatDuration(elapsed))
        }</span>

        <span class="cov0" title="0">if task.Progress != nil </span><span class="cov0" title="0">{
                progress := task.Progress
                completionRate := float64(progress.CompletedTables) / float64(progress.TotalTables)

                // 进度条 - 更宽更美观
                barLength := 40
                filledLength := int(completionRate * float64(barLength))
                bar := "["
                for i := 0; i &lt; barLength; i++ </span><span class="cov0" title="0">{
                        if i &lt; filledLength </span><span class="cov0" title="0">{
                                bar += "█"
                        }</span> else<span class="cov0" title="0"> {
                                bar += "░"
                        }</span>
                }
                <span class="cov0" title="0">bar += "]"

                fmt.Printf("├─ 进度: %s %.1f%% (%d/%d)\n",
                        bar, completionRate*100, progress.CompletedTables, progress.TotalTables)

                if progress.CurrentTable != "" </span><span class="cov0" title="0">{
                        fmt.Printf("├─ 当前表: %s", progress.CurrentTable)
                        if progress.CurrentTableSize &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf(" (%s)", formatBytes(progress.CurrentTableSize))
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("\n")</span>
                }

                // 显示处理统计
                <span class="cov0" title="0">if progress.ProcessedSize &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("├─ 已处理: %s", formatBytes(progress.ProcessedSize))
                        if progress.TotalTables &gt; 0 &amp;&amp; progress.CompletedTables &gt; 0 </span><span class="cov0" title="0">{
                                // 估算总大小（基于已处理的平均大小）
                                avgSize := progress.ProcessedSize / int64(progress.CompletedTables)
                                totalEstimated := avgSize * int64(progress.TotalTables)
                                if totalEstimated &gt; progress.ProcessedSize </span><span class="cov0" title="0">{
                                        remainingSize := totalEstimated - progress.ProcessedSize
                                        fmt.Printf(" (剩余约: %s)", formatBytes(remainingSize))
                                }</span>
                        }
                        <span class="cov0" title="0">fmt.Printf("\n")</span>
                }

                <span class="cov0" title="0">if progress.ReclaimedSpace &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("├─ 已回收: %s", formatBytes(progress.ReclaimedSpace))
                        if progress.ProcessedSize &gt; 0 </span><span class="cov0" title="0">{
                                reclaimeRate := float64(progress.ReclaimedSpace) / float64(progress.ProcessedSize) * 100
                                fmt.Printf(" (回收率: %.1f%%)", reclaimeRate)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("\n")</span>
                }

                // 显示速度和时间信息
                <span class="cov0" title="0">if progress.CompletedTables &gt; 0 &amp;&amp; task.StartedAt != nil </span><span class="cov0" title="0">{
                        elapsed := time.Since(*task.StartedAt)
                        avgTimePerTable := elapsed / time.Duration(progress.CompletedTables)
                        fmt.Printf("├─ 平均每表: %s", formatDuration(avgTimePerTable))

                        // 估算处理速度（表/分钟）
                        tablesPerMinute := float64(progress.CompletedTables) / elapsed.Minutes()
                        if tablesPerMinute &gt; 0 </span><span class="cov0" title="0">{
                                fmt.Printf(" (%.1f表/分钟)", tablesPerMinute)
                        }</span>
                        <span class="cov0" title="0">fmt.Printf("\n")</span>
                }

                <span class="cov0" title="0">if progress.EstimatedRemaining &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("├─ 预计剩余: %s", formatDuration(progress.EstimatedRemaining))
                        
                        // 估算完成时间
                        estimatedFinish := time.Now().Add(progress.EstimatedRemaining)
                        fmt.Printf(" (完成时间: %s)", estimatedFinish.Format("15:04:05"))
                        fmt.Printf("\n")
                }</span>

                <span class="cov0" title="0">if progress.ErrorCount &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Printf("├─ 错误计数: %d\n", progress.ErrorCount)
                }</span>

                // 最后一行
                <span class="cov0" title="0">if task.Progress.LastUpdate.IsZero() </span><span class="cov0" title="0">{
                        fmt.Printf("└─ 最后更新: %s\n", formatDuration(time.Since(task.Progress.StartTime)))
                }</span> else<span class="cov0" title="0"> {
                        fmt.Printf("└─ 最后更新: %s\n", formatDuration(time.Since(task.Progress.LastUpdate)))
                }</span>
        } else<span class="cov0" title="0"> {
                fmt.Printf("└─ 暂无进度信息\n")
        }</span>
}

// getStatusDisplay 获取状态显示文本
func getStatusDisplay(status recycler.TaskStatus) string <span class="cov0" title="0">{
        switch status </span>{
        case recycler.StatusPending:<span class="cov0" title="0">
                return "⏳ 等待中"</span>
        case recycler.StatusRunning:<span class="cov0" title="0">
                return "🔄 运行中"</span>
        case recycler.StatusCompleted:<span class="cov0" title="0">
                return "✅ 已完成"</span>
        case recycler.StatusFailed:<span class="cov0" title="0">
                return "❌ 失败"</span>
        case recycler.StatusCancelled:<span class="cov0" title="0">
                return "⏹️ 已取消"</span>
        case recycler.StatusPaused:<span class="cov0" title="0">
                return "⏸️ 已暂停"</span>
        default:<span class="cov0" title="0">
                return "❓ 未知"</span>
        }
}
</pre>
		
		<pre class="file" id="file9" style="display: none">package cmd

import (
        "context"
        "fmt"
        "os"
        "text/tabwriter"
        "time"

        "mysql_tablespace_recycling/cluster"

        "github.com/spf13/cobra"
)

// 拓扑命令选项
var (
        topologyOutput    string
        topologyMaxDepth  int
        topologyConcurrency int
)

var topologyCmd = &amp;cobra.Command{
        Use:   "topology",
        Short: "发现MySQL集群拓扑结构",
        Long: `自动发现MySQL集群的主从复制拓扑结构。

该命令从指定的MySQL节点开始，通过SHOW SLAVE HOSTS和SHOW SLAVE STATUS
自动探测整个集群的复制关系，构建完整的拓扑图。`,
        Example: `  # 发现本地MySQL的集群拓扑
  mysql-recycler topology

  # 发现指定主机的集群拓扑，输出JSON格式
  mysql-recycler topology --host=192.168.1.100 --output=json

  # 限制探测深度和并发数
  mysql-recycler topology --max-depth=5 --concurrency=3`,
        RunE: runTopology,
}

func init() <span class="cov0" title="0">{
        topologyCmd.Flags().StringVarP(&amp;topologyOutput, "output", "o", "table", "输出格式 (table, json)")
        topologyCmd.Flags().IntVar(&amp;topologyMaxDepth, "max-depth", 5, "最大探测深度")
        topologyCmd.Flags().IntVar(&amp;topologyConcurrency, "concurrency", 3, "并发数")
}</span>

func runTopology(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // 创建节点配置
        nodeConfig, err := createNodeConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create node config: %w", err)
        }</span>

        // 创建拓扑发现器
        <span class="cov0" title="0">factory := &amp;cluster.DefaultConnectionFactory{}
        options := &amp;cluster.DiscoveryOptions{
                MaxConcurrency: topologyConcurrency,
                Timeout:        2 * time.Minute,
                MaxDepth:       topologyMaxDepth,
        }
        discoverer := cluster.NewTopologyDiscoverer(factory, options)

        // 执行拓扑发现
        ctx, cancel := context.WithTimeout(context.Background(), 3*time.Minute)
        defer cancel()

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("正在发现 %s 的集群拓扑...\n", nodeConfig.NodeKey())
        }</span>

        <span class="cov0" title="0">topology, err := discoverer.DiscoverTopology(ctx, nodeConfig.toClusterNodeConfig())
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("topology discovery failed: %w", err)
        }</span>

        // 输出结果
        <span class="cov0" title="0">switch topologyOutput </span>{
        case "json":<span class="cov0" title="0">
                return printJSON(topology)</span>
        case "table":<span class="cov0" title="0">
                return printTopologyReport(topology)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s", topologyOutput)</span>
        }
}

// printTopologyReport 打印拓扑报告
func printTopologyReport(topology *cluster.ClusterTopology) error <span class="cov0" title="0">{
        fmt.Printf("MySQL集群拓扑结构\n")
        fmt.Printf("==================\n")
        fmt.Printf("发现时间: %s\n", topology.DiscoveredAt.Format("2006-01-02 15:04:05"))
        fmt.Printf("总节点数: %d\n", topology.TotalNodes)
        fmt.Println()

        // 显示主节点
        if topology.MasterNode != nil </span><span class="cov0" title="0">{
                fmt.Printf("主节点:\n")
                fmt.Printf("------\n")
                status := topology.GetNodeStatus(topology.MasterNode)
                printNodeInfo(topology.MasterNode, status, "主")
                fmt.Println()
        }</span>

        // 显示从节点
        <span class="cov0" title="0">if len(topology.SlaveNodes) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("从节点:\n")
                fmt.Printf("------\n")
                w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
                fmt.Fprintln(w, "节点\t角色\t只读状态\t服务器ID\t上游主库\t下游从库数\t复制状态")
                fmt.Fprintln(w, "----\t----\t--------\t--------\t--------\t----------\t--------")

                for _, slave := range topology.SlaveNodes </span><span class="cov0" title="0">{
                        status := topology.GetNodeStatus(slave)
                        if status == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">readOnlyStatus := "否"
                        if status.IsReadOnly </span><span class="cov0" title="0">{
                                readOnlyStatus = "是"
                        }</span>

                        <span class="cov0" title="0">masterInfo := "无"
                        replicationStatus := "未知"
                        if status.SlaveStatus != nil </span><span class="cov0" title="0">{
                                masterInfo = fmt.Sprintf("%s:%d", status.SlaveStatus.MasterHost, status.SlaveStatus.MasterPort)
                                if status.SlaveStatus.IsHealthy() </span><span class="cov0" title="0">{
                                        replicationStatus = "正常"
                                }</span> else<span class="cov0" title="0"> {
                                        replicationStatus = "异常"
                                }</span>
                                <span class="cov0" title="0">if status.SlaveStatus.GetReplicationDelay() &gt;= 0 </span><span class="cov0" title="0">{
                                        replicationStatus += fmt.Sprintf(" (延迟%ds)", status.SlaveStatus.GetReplicationDelay())
                                }</span>
                        }

                        <span class="cov0" title="0">downstreamNodes := topology.GetDownstreamNodes(slave)
                        downstreamCount := len(downstreamNodes)

                        fmt.Fprintf(w, "%s\t%s\t%s\t%d\t%s\t%d\t%s\n",
                                slave.NodeKey(),
                                status.Role,
                                readOnlyStatus,
                                status.ServerID,
                                masterInfo,
                                downstreamCount,
                                replicationStatus,
                        )</span>
                }
                <span class="cov0" title="0">w.Flush()
                fmt.Println()</span>
        }

        // 显示复制关系
        <span class="cov0" title="0">if len(topology.Relationships) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("复制关系:\n")
                fmt.Printf("--------\n")
                printReplicationTree(topology, topology.MasterNode, 0)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// printNodeInfo 打印节点信息
func printNodeInfo(node *cluster.NodeConfig, status *cluster.NodeStatus, role string) <span class="cov0" title="0">{
        fmt.Printf("  地址: %s\n", node.NodeKey())
        if status != nil </span><span class="cov0" title="0">{
                fmt.Printf("  角色: %s\n", role)
                fmt.Printf("  只读: %t\n", status.IsReadOnly)
                fmt.Printf("  服务器ID: %d\n", status.ServerID)
                fmt.Printf("  下游从库: %d个\n", len(status.SlaveHosts))
                fmt.Printf("  最后检查: %s\n", status.LastCheck.Format("2006-01-02 15:04:05"))
        }</span>
}

// printReplicationTree 打印复制树
func printReplicationTree(topology *cluster.ClusterTopology, node *cluster.NodeConfig, depth int) <span class="cov0" title="0">{
        if node == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">indent := ""
        for i := 0; i &lt; depth; i++ </span><span class="cov0" title="0">{
                if i == depth-1 </span><span class="cov0" title="0">{
                        indent += "├── "
                }</span> else<span class="cov0" title="0"> {
                        indent += "│   "
                }</span>
        }

        <span class="cov0" title="0">if depth == 0 </span><span class="cov0" title="0">{
                fmt.Printf("%s (主)\n", node.NodeKey())
        }</span> else<span class="cov0" title="0"> {
                status := topology.GetNodeStatus(node)
                statusInfo := ""
                if status != nil &amp;&amp; status.SlaveStatus != nil </span><span class="cov0" title="0">{
                        if status.SlaveStatus.IsHealthy() </span><span class="cov0" title="0">{
                                statusInfo = " [正常]"
                        }</span> else<span class="cov0" title="0"> {
                                statusInfo = " [异常]"
                        }</span>
                        <span class="cov0" title="0">if lag := status.SlaveStatus.GetReplicationDelay(); lag &gt;= 0 </span><span class="cov0" title="0">{
                                statusInfo += fmt.Sprintf(" (延迟%ds)", lag)
                        }</span>
                }
                <span class="cov0" title="0">fmt.Printf("%s%s%s\n", indent, node.NodeKey(), statusInfo)</span>
        }

        // 递归打印下游节点
        <span class="cov0" title="0">downstreamNodes := topology.GetDownstreamNodes(node)
        for _, downstream := range downstreamNodes </span><span class="cov0" title="0">{
                printReplicationTree(topology, downstream, depth+1)
        }</span>
}</pre>
		
		<pre class="file" id="file10" style="display: none">package cmd

import (
        "fmt"
        "strings"
)

// parseSizeStr 解析大小字符串为字节数（避免和parseSize冲突）
func parseSizeStr(sizeStr string) (int64, error) <span class="cov0" title="0">{
        if sizeStr == "" </span><span class="cov0" title="0">{
                return 0, nil
        }</span>
        
        <span class="cov0" title="0">sizeStr = strings.ToUpper(strings.TrimSpace(sizeStr))
        
        var multiplier int64 = 1
        var numStr string
        
        if strings.HasSuffix(sizeStr, "B") </span><span class="cov0" title="0">{
                numStr = strings.TrimSuffix(sizeStr, "B")
                multiplier = 1
        }</span> else<span class="cov0" title="0"> if strings.HasSuffix(sizeStr, "KB") </span><span class="cov0" title="0">{
                numStr = strings.TrimSuffix(sizeStr, "KB")
                multiplier = 1024
        }</span> else<span class="cov0" title="0"> if strings.HasSuffix(sizeStr, "MB") </span><span class="cov0" title="0">{
                numStr = strings.TrimSuffix(sizeStr, "MB")
                multiplier = 1024 * 1024
        }</span> else<span class="cov0" title="0"> if strings.HasSuffix(sizeStr, "GB") </span><span class="cov0" title="0">{
                numStr = strings.TrimSuffix(sizeStr, "GB")
                multiplier = 1024 * 1024 * 1024
        }</span> else<span class="cov0" title="0"> if strings.HasSuffix(sizeStr, "TB") </span><span class="cov0" title="0">{
                numStr = strings.TrimSuffix(sizeStr, "TB")
                multiplier = 1024 * 1024 * 1024 * 1024
        }</span> else<span class="cov0" title="0"> {
                numStr = sizeStr
        }</span>
        
        <span class="cov0" title="0">var size float64
        _, err := fmt.Sscanf(numStr, "%f", &amp;size)
        if err != nil </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid size format: %s", sizeStr)
        }</span>
        
        <span class="cov0" title="0">return int64(size * float64(multiplier)), nil</span>
}</pre>
		
		<pre class="file" id="file11" style="display: none">package cmd

import (
        "context"
        "fmt"
        "os"
        "text/tabwriter"
        "time"

        "mysql_tablespace_recycling/cluster"

        "github.com/spf13/cobra"
)

// 验证命令选项
var (
        validateOutput     string
        validateStrictMode bool
)

var validateCmd = &amp;cobra.Command{
        Use:   "validate",
        Short: "验证节点角色和操作安全性",
        Long: `验证MySQL节点的角色（主/从）和执行表空间回收操作的安全性。

该命令使用多种方式验证节点身份，包括：
- 检查read_only和super_read_only状态
- 分析SLAVE STATUS和SLAVE HOSTS信息
- 调用外部集群管理API（如果配置）
- 评估操作风险等级

主要用于在执行表空间回收前确认目标节点的安全性。`,
        Example: `  # 验证本地MySQL节点
  mysql-recycler validate

  # 验证指定节点，输出详细信息
  mysql-recycler validate --host=192.168.1.101 --verbose

  # 严格模式验证（要求高信心度）
  mysql-recycler validate --host=192.168.1.101 --strict

  # 输出JSON格式的验证结果
  mysql-recycler validate --host=192.168.1.101 --output=json`,
        RunE: runValidate,
}

func init() <span class="cov0" title="0">{
        validateCmd.Flags().StringVarP(&amp;validateOutput, "output", "o", "table", "输出格式 (table, json)")
        validateCmd.Flags().BoolVar(&amp;validateStrictMode, "strict", false, "严格模式验证")
}</span>

func runValidate(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        // 创建节点配置
        nodeConfig, err := createNodeConfig()
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create node config: %w", err)
        }</span>

        // 创建组件
        <span class="cov0" title="0">factory := &amp;cluster.DefaultConnectionFactory{}
        options := &amp;cluster.DiscoveryOptions{
                MaxConcurrency: 3,
                Timeout:        30 * time.Second,
                MaxDepth:       1, // 只需要验证当前节点
        }
        discoverer := cluster.NewTopologyDiscoverer(factory, options)
        validator := cluster.NewMasterValidator(discoverer, nil, factory, validateStrictMode)

        // 执行验证
        ctx, cancel := context.WithTimeout(context.Background(), 1*time.Minute)
        defer cancel()

        if verbose </span><span class="cov0" title="0">{
                fmt.Printf("正在验证 %s 的节点角色和安全性...\n", nodeConfig.NodeKey())
        }</span>

        <span class="cov0" title="0">clusterNodeConfig := nodeConfig.toClusterNodeConfig()
        result, err := validator.GetMasterValidationResult(ctx, clusterNodeConfig)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("validation failed: %w", err)
        }</span>

        // 输出结果
        <span class="cov0" title="0">switch validateOutput </span>{
        case "json":<span class="cov0" title="0">
                return printJSON(result)</span>
        case "table":<span class="cov0" title="0">
                return printValidationReport(nodeConfig, result)</span>
        default:<span class="cov0" title="0">
                return fmt.Errorf("unsupported output format: %s", validateOutput)</span>
        }
}

// printValidationReport 打印验证报告
func printValidationReport(nodeConfig *NodeConfig, result *cluster.MasterValidationResult) error <span class="cov0" title="0">{
        fmt.Printf("MySQL节点角色验证报告\n")
        fmt.Printf("====================\n")
        fmt.Printf("节点: %s\n", nodeConfig.NodeKey())
        fmt.Printf("验证时间: %s\n", time.Now().Format("2006-01-02 15:04:05"))
        fmt.Println()

        // 主要结论
        fmt.Printf("验证结果:\n")
        fmt.Printf("--------\n")
        
        nodeType := "从节点"
        if result.IsMaster </span><span class="cov0" title="0">{
                nodeType = "主节点"
        }</span>
        <span class="cov0" title="0">fmt.Printf("节点类型: %s\n", nodeType)
        fmt.Printf("验证信心度: %s\n", getConfidenceDisplay(result.Confidence))
        
        safetyStatus := "✓ 安全"
        if result.IsMaster </span><span class="cov0" title="0">{
                safetyStatus = "⚠ 危险 - 主节点操作需谨慎"
        }</span>
        <span class="cov0" title="0">fmt.Printf("操作安全性: %s\n", safetyStatus)
        fmt.Println()

        // 验证方法
        fmt.Printf("验证方法:\n")
        fmt.Printf("--------\n")
        for i, method := range result.ValidationMethods </span><span class="cov0" title="0">{
                fmt.Printf("%d. %s\n", i+1, getMethodDisplay(method))
        }</span>
        <span class="cov0" title="0">fmt.Println()

        // 数据库状态
        if result.DatabaseStatus != nil </span><span class="cov0" title="0">{
                fmt.Printf("数据库状态:\n")
                fmt.Printf("----------\n")
                
                w := tabwriter.NewWriter(os.Stdout, 0, 0, 2, ' ', 0)
                fmt.Fprintln(w, "项目\t状态\t说明")
                fmt.Fprintln(w, "----\t----\t----")
                
                readOnlyStatus := "ON (只读)"
                if !result.DatabaseStatus.ReadOnly </span><span class="cov0" title="0">{
                        readOnlyStatus = "OFF (可写)"
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(w, "read_only\t%s\t%s\n", readOnlyStatus, getReadOnlyDescription(result.DatabaseStatus.ReadOnly))
                
                if result.DatabaseStatus.SuperReadOnly </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "super_read_only\tON\t超级只读模式\n")
                }</span>
                
                <span class="cov0" title="0">fmt.Fprintf(w, "server_id\t%d\t服务器标识\n", result.DatabaseStatus.ServerID)
                
                binlogStatus := "OFF"
                if result.DatabaseStatus.LogBin </span><span class="cov0" title="0">{
                        binlogStatus = "ON"
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(w, "log_bin\t%s\t二进制日志\n", binlogStatus)
                
                if result.DatabaseStatus.BinlogFormat != "" </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "binlog_format\t%s\t二进制日志格式\n", result.DatabaseStatus.BinlogFormat)
                }</span>
                
                <span class="cov0" title="0">if result.DatabaseStatus.HasSlaveStatus </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "复制状态\t有\t作为从库运行\n")
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(w, "复制状态\t无\t不是从库\n")
                }</span>
                
                <span class="cov0" title="0">if result.DatabaseStatus.SlaveCount &gt; 0 </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "从库连接\t%d个\t作为主库为从库提供服务\n", result.DatabaseStatus.SlaveCount)
                }</span>
                
                <span class="cov0" title="0">w.Flush()
                fmt.Println()</span>
        }

        // 验证理由
        <span class="cov0" title="0">if len(result.Reasons) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("验证依据:\n")
                fmt.Printf("--------\n")
                for i, reason := range result.Reasons </span><span class="cov0" title="0">{
                        fmt.Printf("%d. %s\n", i+1, reason)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // 外部API结果
        <span class="cov0" title="0">if result.ExternalAPIResult != nil </span><span class="cov0" title="0">{
                fmt.Printf("外部API验证:\n")
                fmt.Printf("-----------\n")
                fmt.Printf("集群名称: %s\n", result.ExternalAPIResult.ClusterName)
                fmt.Printf("集群组: %s\n", result.ExternalAPIResult.ClusterGroupName)
                fmt.Printf("实例角色: %s\n", result.ExternalAPIResult.InstanceRole)
                fmt.Printf("只读状态: %s\n", result.ExternalAPIResult.InstanceReadOnly)
                fmt.Println()
        }</span>

        // 警告信息
        <span class="cov0" title="0">if len(result.Warnings) &gt; 0 </span><span class="cov0" title="0">{
                fmt.Printf("警告信息:\n")
                fmt.Printf("--------\n")
                for i, warning := range result.Warnings </span><span class="cov0" title="0">{
                        fmt.Printf("⚠ %d. %s\n", i+1, warning)
                }</span>
                <span class="cov0" title="0">fmt.Println()</span>
        }

        // 操作建议
        <span class="cov0" title="0">fmt.Printf("操作建议:\n")
        fmt.Printf("--------\n")
        if result.IsMaster </span><span class="cov0" title="0">{
                fmt.Printf("❌ 不建议在主节点上执行表空间回收操作\n")
                fmt.Printf("   - 表空间回收会锁定表，影响业务读写\n")
                fmt.Printf("   - 建议在从节点上执行，或在维护窗口期间执行\n")
                fmt.Printf("   - 如确需在主节点执行，请使用 --allow-master 参数\n")
        }</span> else<span class="cov0" title="0"> {
                fmt.Printf("✓ 可以安全地在此从节点上执行表空间回收操作\n")
                fmt.Printf("   - 建议在业务低峰期执行以减少影响\n")
                fmt.Printf("   - 执行前请确保有完整的数据备份\n")
                
                if result.Confidence == cluster.ConfidenceLow || result.Confidence == cluster.ConfidenceNone </span><span class="cov0" title="0">{
                        fmt.Printf("   - 验证信心度较低，建议进一步确认节点状态\n")
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// getConfidenceDisplay 获取信心度显示文本
func getConfidenceDisplay(confidence cluster.ValidationConfidence) string <span class="cov0" title="0">{
        switch confidence </span>{
        case cluster.ConfidenceHigh:<span class="cov0" title="0">
                return "高 (可信)"</span>
        case cluster.ConfidenceMedium:<span class="cov0" title="0">
                return "中 (较可信)"</span>
        case cluster.ConfidenceLow:<span class="cov0" title="0">
                return "低 (需谨慎)"</span>
        case cluster.ConfidenceNone:<span class="cov0" title="0">
                return "无 (无法确定)"</span>
        default:<span class="cov0" title="0">
                return string(confidence)</span>
        }
}

// getMethodDisplay 获取验证方法显示文本
func getMethodDisplay(method cluster.ValidationMethod) string <span class="cov0" title="0">{
        switch method </span>{
        case cluster.ValidationReadOnly:<span class="cov0" title="0">
                return "read_only状态检查"</span>
        case cluster.ValidationSlaveStatus:<span class="cov0" title="0">
                return "SLAVE STATUS分析"</span>
        case cluster.ValidationSlaveHosts:<span class="cov0" title="0">
                return "SLAVE HOSTS检查"</span>
        case cluster.ValidationExternalAPI:<span class="cov0" title="0">
                return "外部API验证"</span>
        case cluster.ValidationProcessList:<span class="cov0" title="0">
                return "进程列表检查"</span>
        default:<span class="cov0" title="0">
                return string(method)</span>
        }
}

// getReadOnlyDescription 获取只读状态描述
func getReadOnlyDescription(readOnly bool) string <span class="cov0" title="0">{
        if readOnly </span><span class="cov0" title="0">{
                return "通常表示从节点"
        }</span> else<span class="cov0" title="0"> {
                return "通常表示主节点"
        }</span>
}</pre>
		
		<pre class="file" id="file12" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"
        "time"

        "gopkg.in/yaml.v3"
)

// Config 主配置结构
type Config struct {
        Database    DatabaseConfig    `yaml:"database" json:"database"`
        Recycler    RecyclerConfig    `yaml:"recycler" json:"recycler"`
        Monitoring  MonitoringConfig  `yaml:"monitoring" json:"monitoring"`
        ExternalAPI ExternalAPIConfig `yaml:"external_api" json:"external_api"`
        Logging     LoggingConfig     `yaml:"logging" json:"logging"`
}

// DatabaseConfig 数据库配置
type DatabaseConfig struct {
        DefaultHost     string        `yaml:"default_host" json:"default_host"`
        DefaultPort     int           `yaml:"default_port" json:"default_port"`
        DefaultUser     string        `yaml:"default_user" json:"default_user"`
        DefaultDatabase string        `yaml:"default_database" json:"default_database"`
        Timeout         time.Duration `yaml:"timeout" json:"timeout"`
        MaxConnections  int           `yaml:"max_connections" json:"max_connections"`
        ConnMaxLifetime time.Duration `yaml:"conn_max_lifetime" json:"conn_max_lifetime"`
        ConnMaxIdleTime time.Duration `yaml:"conn_max_idle_time" json:"conn_max_idle_time"`
}

// RecyclerConfig 回收器配置
type RecyclerConfig struct {
        DefaultThreshold        string        `yaml:"default_threshold" json:"default_threshold"`
        DefaultMode             int           `yaml:"default_mode" json:"default_mode"`
        MaxConcurrency         int           `yaml:"max_concurrency" json:"max_concurrency"`
        DefaultConcurrency     int           `yaml:"default_concurrency" json:"default_concurrency"`
        AllowMasterOperations  bool          `yaml:"allow_master_operations" json:"allow_master_operations"`
        SafetyCheckInterval    time.Duration `yaml:"safety_check_interval" json:"safety_check_interval"`
        TableLockTimeout       time.Duration `yaml:"table_lock_timeout" json:"table_lock_timeout"`
        MinTableSize           string        `yaml:"min_table_size" json:"min_table_size"`
        MaxTableSize           string        `yaml:"max_table_size" json:"max_table_size"`
        SupportedEngines       []string      `yaml:"supported_engines" json:"supported_engines"`
        ExcludeSchemas         []string      `yaml:"exclude_schemas" json:"exclude_schemas"`
}

// MonitoringConfig 监控配置
type MonitoringConfig struct {
        StatusFile         string        `yaml:"status_file" json:"status_file"`
        PersistInterval    time.Duration `yaml:"persist_interval" json:"persist_interval"`
        MaxHistoryRecords  int           `yaml:"max_history_records" json:"max_history_records"`
        EnableAutoSave     bool          `yaml:"enable_auto_save" json:"enable_auto_save"`
        EnableNotification bool          `yaml:"enable_notification" json:"enable_notification"`
        WebhookURL         string        `yaml:"webhook_url" json:"webhook_url"`
}

// ExternalAPIConfig 外部API配置
type ExternalAPIConfig struct {
        ClusterInfoURL string        `yaml:"cluster_info_url" json:"cluster_info_url"`
        Timeout        time.Duration `yaml:"timeout" json:"timeout"`
        RetryTimes     int           `yaml:"retry_times" json:"retry_times"`
        EnableCache    bool          `yaml:"enable_cache" json:"enable_cache"`
        CacheTimeout   time.Duration `yaml:"cache_timeout" json:"cache_timeout"`
        AuthToken      string        `yaml:"auth_token" json:"auth_token"`
}

// LoggingConfig 日志配置
type LoggingConfig struct {
        Level      string `yaml:"level" json:"level"`
        Format     string `yaml:"format" json:"format"`
        OutputFile string `yaml:"output_file" json:"output_file"`
        MaxSize    int    `yaml:"max_size" json:"max_size"`       // MB
        MaxBackups int    `yaml:"max_backups" json:"max_backups"` // 备份文件数
        MaxAge     int    `yaml:"max_age" json:"max_age"`         // 天数
        Compress   bool   `yaml:"compress" json:"compress"`
}

// GetDefaultConfig 获取默认配置
func GetDefaultConfig() *Config <span class="cov0" title="0">{
        return &amp;Config{
                Database: DatabaseConfig{
                        DefaultHost:     "localhost",
                        DefaultPort:     3306,
                        DefaultUser:     "root",
                        DefaultDatabase: "information_schema",
                        Timeout:         30 * time.Second,
                        MaxConnections:  10,
                        ConnMaxLifetime: 5 * time.Minute,
                        ConnMaxIdleTime: 1 * time.Minute,
                },
                Recycler: RecyclerConfig{
                        DefaultThreshold:       "100MB",
                        DefaultMode:            1,
                        MaxConcurrency:         10,
                        DefaultConcurrency:     3,
                        AllowMasterOperations:  false,
                        SafetyCheckInterval:    30 * time.Second,
                        TableLockTimeout:       5 * time.Minute,
                        MinTableSize:           "10MB",
                        MaxTableSize:           "",
                        SupportedEngines:       []string{"InnoDB"},
                        ExcludeSchemas:        []string{"information_schema", "performance_schema", "mysql", "sys"},
                },
                Monitoring: MonitoringConfig{
                        StatusFile:         "/tmp/mysql-recycler-status.json",
                        PersistInterval:    5 * time.Minute,
                        MaxHistoryRecords:  1000,
                        EnableAutoSave:     true,
                        EnableNotification: false,
                        WebhookURL:         "",
                },
                ExternalAPI: ExternalAPIConfig{
                        ClusterInfoURL: "",
                        Timeout:        10 * time.Second,
                        RetryTimes:     3,
                        EnableCache:    true,
                        CacheTimeout:   5 * time.Minute,
                        AuthToken:      "",
                },
                Logging: LoggingConfig{
                        Level:      "info",
                        Format:     "text",
                        OutputFile: "",
                        MaxSize:    100,
                        MaxBackups: 3,
                        MaxAge:     7,
                        Compress:   true,
                },
        }
}</span>

// LoadConfig 从文件加载配置
func LoadConfig(configFile string) (*Config, error) <span class="cov0" title="0">{
        config := GetDefaultConfig()

        if configFile == "" </span><span class="cov0" title="0">{
                return config, nil
        }</span>

        // 检查文件是否存在
        <span class="cov0" title="0">if _, err := os.Stat(configFile); os.IsNotExist(err) </span><span class="cov0" title="0">{
                return config, nil // 使用默认配置
        }</span>

        <span class="cov0" title="0">data, err := os.ReadFile(configFile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read config file %s: %w", configFile, err)
        }</span>

        <span class="cov0" title="0">if err := yaml.Unmarshal(data, config); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse config file %s: %w", configFile, err)
        }</span>

        // 验证配置
        <span class="cov0" title="0">if err := config.Validate(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("invalid configuration: %w", err)
        }</span>

        <span class="cov0" title="0">return config, nil</span>
}

// LoadConfigFromEnv 从环境变量加载配置
func LoadConfigFromEnv(config *Config) <span class="cov0" title="0">{
        if host := os.Getenv("MYSQL_RECYCLER_HOST"); host != "" </span><span class="cov0" title="0">{
                config.Database.DefaultHost = host
        }</span>
        <span class="cov0" title="0">if port := os.Getenv("MYSQL_RECYCLER_PORT"); port != "" </span><span class="cov0" title="0">{
                if p, err := parsePort(port); err == nil </span><span class="cov0" title="0">{
                        config.Database.DefaultPort = p
                }</span>
        }
        <span class="cov0" title="0">if user := os.Getenv("MYSQL_RECYCLER_USER"); user != "" </span><span class="cov0" title="0">{
                config.Database.DefaultUser = user
        }</span>
        <span class="cov0" title="0">if database := os.Getenv("MYSQL_RECYCLER_DATABASE"); database != "" </span><span class="cov0" title="0">{
                config.Database.DefaultDatabase = database
        }</span>
        <span class="cov0" title="0">if threshold := os.Getenv("MYSQL_RECYCLER_THRESHOLD"); threshold != "" </span><span class="cov0" title="0">{
                config.Recycler.DefaultThreshold = threshold
        }</span>
        <span class="cov0" title="0">if concurrency := os.Getenv("MYSQL_RECYCLER_CONCURRENCY"); concurrency != "" </span><span class="cov0" title="0">{
                if c, err := parseIntValue(concurrency); err == nil </span><span class="cov0" title="0">{
                        config.Recycler.DefaultConcurrency = c
                }</span>
        }
        <span class="cov0" title="0">if logLevel := os.Getenv("MYSQL_RECYCLER_LOG_LEVEL"); logLevel != "" </span><span class="cov0" title="0">{
                config.Logging.Level = logLevel
        }</span>
        <span class="cov0" title="0">if logFormat := os.Getenv("MYSQL_RECYCLER_LOG_FORMAT"); logFormat != "" </span><span class="cov0" title="0">{
                config.Logging.Format = logFormat
        }</span>
        <span class="cov0" title="0">if statusFile := os.Getenv("MYSQL_RECYCLER_STATUS_FILE"); statusFile != "" </span><span class="cov0" title="0">{
                config.Monitoring.StatusFile = statusFile
        }</span>
        <span class="cov0" title="0">if webhookURL := os.Getenv("MYSQL_RECYCLER_WEBHOOK_URL"); webhookURL != "" </span><span class="cov0" title="0">{
                config.Monitoring.WebhookURL = webhookURL
                config.Monitoring.EnableNotification = true
        }</span>
}

// SaveConfig 保存配置到文件
func SaveConfig(config *Config, configFile string) error <span class="cov0" title="0">{
        // 确保目录存在
        dir := filepath.Dir(configFile)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create config directory: %w", err)
        }</span>

        <span class="cov0" title="0">data, err := yaml.Marshal(config)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to marshal config: %w", err)
        }</span>

        <span class="cov0" title="0">if err := os.WriteFile(configFile, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write config file: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// Validate 验证配置有效性
func (c *Config) Validate() error <span class="cov0" title="0">{
        // 验证数据库配置
        if c.Database.DefaultPort &lt;= 0 || c.Database.DefaultPort &gt; 65535 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid database port: %d", c.Database.DefaultPort)
        }</span>
        
        <span class="cov0" title="0">if c.Database.Timeout &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("database timeout must be positive")
        }</span>

        // 验证回收器配置
        <span class="cov0" title="0">if c.Recycler.MaxConcurrency &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max concurrency must be positive")
        }</span>
        
        <span class="cov0" title="0">if c.Recycler.DefaultConcurrency &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("default concurrency must be positive")
        }</span>
        
        <span class="cov0" title="0">if c.Recycler.DefaultConcurrency &gt; c.Recycler.MaxConcurrency </span><span class="cov0" title="0">{
                return fmt.Errorf("default concurrency cannot exceed max concurrency")
        }</span>

        // 验证监控配置
        <span class="cov0" title="0">if c.Monitoring.MaxHistoryRecords &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("max history records must be positive")
        }</span>

        // 验证日志级别
        <span class="cov0" title="0">validLogLevels := []string{"debug", "info", "warn", "error"}
        validLevel := false
        for _, level := range validLogLevels </span><span class="cov0" title="0">{
                if c.Logging.Level == level </span><span class="cov0" title="0">{
                        validLevel = true
                        break</span>
                }
        }
        <span class="cov0" title="0">if !validLevel </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid log level: %s", c.Logging.Level)
        }</span>

        // 验证日志格式
        <span class="cov0" title="0">if c.Logging.Format != "text" &amp;&amp; c.Logging.Format != "json" </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid log format: %s", c.Logging.Format)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// GetConfigSearchPaths 获取配置文件搜索路径
func GetConfigSearchPaths() []string <span class="cov0" title="0">{
        paths := []string{}

        // 当前目录
        if cwd, err := os.Getwd(); err == nil </span><span class="cov0" title="0">{
                paths = append(paths, filepath.Join(cwd, "mysql-recycler.yaml"))
                paths = append(paths, filepath.Join(cwd, "mysql-recycler.yml"))
                paths = append(paths, filepath.Join(cwd, ".mysql-recycler.yaml"))
                paths = append(paths, filepath.Join(cwd, ".mysql-recycler.yml"))
        }</span>

        // 用户主目录
        <span class="cov0" title="0">if home, err := os.UserHomeDir(); err == nil </span><span class="cov0" title="0">{
                paths = append(paths, filepath.Join(home, ".mysql-recycler.yaml"))
                paths = append(paths, filepath.Join(home, ".mysql-recycler.yml"))
                paths = append(paths, filepath.Join(home, ".config", "mysql-recycler", "config.yaml"))
                paths = append(paths, filepath.Join(home, ".config", "mysql-recycler", "config.yml"))
        }</span>

        // 系统配置目录
        <span class="cov0" title="0">paths = append(paths, "/etc/mysql-recycler/config.yaml")
        paths = append(paths, "/etc/mysql-recycler/config.yml")

        return paths</span>
}

// FindConfigFile 查找配置文件
func FindConfigFile() string <span class="cov0" title="0">{
        for _, path := range GetConfigSearchPaths() </span><span class="cov0" title="0">{
                if _, err := os.Stat(path); err == nil </span><span class="cov0" title="0">{
                        return path
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// GenerateExampleConfig 生成示例配置文件
func GenerateExampleConfig() string <span class="cov0" title="0">{
        return `# MySQL表空间回收工具配置文件示例

# 数据库连接配置
database:
  default_host: "localhost"
  default_port: 3306
  default_user: "root"
  default_database: "information_schema"
  timeout: "30s"
  max_connections: 10
  conn_max_lifetime: "5m"
  conn_max_idle_time: "1m"

# 回收器配置
recycler:
  default_threshold: "100MB"        # 默认碎片回收阈值
  default_mode: 1                   # 1=独立节点模式, 2=复制同步模式
  max_concurrency: 10               # 最大并发数
  default_concurrency: 3            # 默认并发数
  allow_master_operations: false    # 是否允许在主节点执行操作
  safety_check_interval: "30s"      # 安全检查间隔
  table_lock_timeout: "5m"          # 表锁超时时间
  min_table_size: "10MB"            # 最小表大小
  max_table_size: ""                # 最大表大小（空表示无限制）
  supported_engines:                # 支持的存储引擎
    - "InnoDB"
  exclude_schemas:                  # 默认排除的数据库
    - "information_schema"
    - "performance_schema"
    - "mysql"
    - "sys"

# 监控配置
monitoring:
  status_file: "/tmp/mysql-recycler-status.json"
  persist_interval: "5m"
  max_history_records: 1000
  enable_auto_save: true
  enable_notification: false
  webhook_url: ""                   # Webhook通知URL

# 外部API配置
external_api:
  cluster_info_url: ""              # 集群信息API URL
  timeout: "10s"
  retry_times: 3
  enable_cache: true
  cache_timeout: "5m"
  auth_token: ""                    # 认证令牌

# 日志配置
logging:
  level: "info"                     # debug, info, warn, error
  format: "text"                    # text, json
  output_file: ""                   # 空表示输出到控制台
  max_size: 100                     # 日志文件最大大小(MB)
  max_backups: 3                    # 保留的备份文件数
  max_age: 7                        # 日志文件最大保留天数
  compress: true                    # 是否压缩旧日志文件
`
}</span>

// 辅助函数

func parsePort(portStr string) (int, error) <span class="cov0" title="0">{
        port := 0
        _, err := fmt.Sscanf(portStr, "%d", &amp;port)
        if err != nil || port &lt;= 0 || port &gt; 65535 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid port: %s", portStr)
        }</span>
        <span class="cov0" title="0">return port, nil</span>
}

func parseIntValue(valueStr string) (int, error) <span class="cov0" title="0">{
        value := 0
        _, err := fmt.Sscanf(valueStr, "%d", &amp;value)
        if err != nil || value &lt; 0 </span><span class="cov0" title="0">{
                return 0, fmt.Errorf("invalid integer value: %s", valueStr)
        }</span>
        <span class="cov0" title="0">return value, nil</span>
}</pre>
		
		<pre class="file" id="file13" style="display: none">package main

import (
        "mysql_tablespace_recycling/cmd"
)

func main() <span class="cov0" title="0">{
        cmd.Execute()
}</span>
</pre>
		
		<pre class="file" id="file14" style="display: none">package monitor

import (
        "context"
        "encoding/json"
        "fmt"
        "os"
        "sync"
        "time"

        "mysql_tablespace_recycling/recycler"
)

// Monitor 监控器接口
type Monitor interface {
        // StartTask 开始监控任务
        StartTask(task *recycler.RecycleTask) error

        // UpdateProgress 更新任务进度
        UpdateProgress(taskID string, progress *recycler.TaskProgress) error

        // UpdateTaskStatus 更新任务状态
        UpdateTaskStatus(taskID string, status recycler.TaskStatus) error

        // GetTaskStatus 获取任务状态
        GetTaskStatus(taskID string) (*TaskStatus, error)

        // ListActiveTasks 列出活跃任务
        ListActiveTasks() ([]*TaskStatus, error)

        // GetTaskHistory 获取任务历史
        GetTaskHistory(limit int) ([]*TaskStatus, error)

        // PersistStatus 持久化状态到文件
        PersistStatus() error

        // LoadStatus 从文件加载状态
        LoadStatus() error

        // RegisterHook 注册监控钩子
        RegisterHook(hook MonitorHook) error

        // StartBackgroundPersistence 启动后台持久化
        StartBackgroundPersistence(ctx context.Context, interval time.Duration) error

        // GetStats 获取监控统计信息
        GetStats() *MonitorStats

        // CompleteTask 完成任务
        CompleteTask(taskID string, result *recycler.RecycleResult, err error) error

        // Shutdown 优雅关闭监控器
        Shutdown() error
}

// TaskStatus 任务状态（扩展版本）
type TaskStatus struct {
        TaskID       string                  `json:"task_id"`
        Target       *recycler.RecycleTarget `json:"target"`
        Status       recycler.TaskStatus     `json:"status"`
        Progress     *recycler.TaskProgress  `json:"progress,omitempty"`
        Result       *recycler.RecycleResult `json:"result,omitempty"`
        CreatedAt    time.Time               `json:"created_at"`
        StartedAt    *time.Time              `json:"started_at,omitempty"`
        CompletedAt  *time.Time              `json:"completed_at,omitempty"`
        LastUpdate   time.Time               `json:"last_update"`
        ErrorMessage string                  `json:"error_message,omitempty"`
        Warnings     []string                `json:"warnings,omitempty"`
        Metadata     map[string]interface{}  `json:"metadata,omitempty"`
}

// MonitorStats 监控统计信息
type MonitorStats struct {
        ActiveTasks          int           `json:"active_tasks"`
        CompletedTasks       int           `json:"completed_tasks"`
        FailedTasks          int           `json:"failed_tasks"`
        TotalReclaimedSpace  int64         `json:"total_reclaimed_space"`
        TotalProcessedTables int           `json:"total_processed_tables"`
        AverageTaskDuration  time.Duration `json:"average_task_duration"`
        LastPersistTime      time.Time     `json:"last_persist_time"`
        UptimeStart          time.Time     `json:"uptime_start"`
}

// MonitorHook 监控钩子接口
type MonitorHook interface {
        // OnTaskStart 任务开始时调用
        OnTaskStart(taskStatus *TaskStatus) error

        // OnTaskProgress 任务进度更新时调用
        OnTaskProgress(taskStatus *TaskStatus) error

        // OnTaskComplete 任务完成时调用
        OnTaskComplete(taskStatus *TaskStatus) error

        // OnTaskFailed 任务失败时调用
        OnTaskFailed(taskStatus *TaskStatus, err error) error
}

// DefaultMonitor 默认监控器实现
type DefaultMonitor struct {
        mu                sync.RWMutex
        tasks             map[string]*TaskStatus
        taskHistory       []*TaskStatus
        hooks             []MonitorHook
        statusFile        string
        maxHistoryRecords int
        stats             *MonitorStats
        persistenceTicker *time.Ticker
        ctx               context.Context
        cancel            context.CancelFunc
}

// MonitorConfig 监控器配置
type MonitorConfig struct {
        StatusFile        string        `json:"status_file" yaml:"status_file"`
        MaxHistoryRecords int           `json:"max_history_records" yaml:"max_history_records"`
        PersistInterval   time.Duration `json:"persist_interval" yaml:"persist_interval"`
        EnableAutoSave    bool          `json:"enable_auto_save" yaml:"enable_auto_save"`
}

// NewMonitor 创建监控器
func NewMonitor(config *MonitorConfig) Monitor <span class="cov0" title="0">{
        if config == nil </span><span class="cov0" title="0">{
                config = &amp;MonitorConfig{
                        StatusFile:        "/tmp/mysql-recycler-status.json",
                        MaxHistoryRecords: 1000,
                        PersistInterval:   5 * time.Minute,
                        EnableAutoSave:    true,
                }
        }</span>

        <span class="cov0" title="0">ctx, cancel := context.WithCancel(context.Background())

        monitor := &amp;DefaultMonitor{
                tasks:             make(map[string]*TaskStatus),
                taskHistory:       make([]*TaskStatus, 0),
                hooks:             make([]MonitorHook, 0),
                statusFile:        config.StatusFile,
                maxHistoryRecords: config.MaxHistoryRecords,
                ctx:               ctx,
                cancel:            cancel,
                stats: &amp;MonitorStats{
                        UptimeStart: time.Now(),
                },
        }

        // 自动加载持久化状态
        if err := monitor.LoadStatus(); err != nil </span><span class="cov0" title="0">{
                // 记录错误但不中断初始化，因为可能是第一次运行
                fmt.Printf("Warning: failed to load monitor status: %v\n", err)
        }</span>

        // 启动后台持久化
        <span class="cov0" title="0">if config.EnableAutoSave </span><span class="cov0" title="0">{
                go monitor.StartBackgroundPersistence(ctx, config.PersistInterval)
        }</span>

        <span class="cov0" title="0">return monitor</span>
}

// StartTask 开始监控任务
func (m *DefaultMonitor) StartTask(task *recycler.RecycleTask) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        now := time.Now()
        taskStatus := &amp;TaskStatus{
                TaskID:     task.ID,
                Target:     task.Target,
                Status:     task.Status,
                Progress:   task.Progress,
                CreatedAt:  task.CreatedAt,
                StartedAt:  &amp;now,
                LastUpdate: now,
                Metadata:   make(map[string]interface{}),
        }

        m.tasks[task.ID] = taskStatus
        m.stats.ActiveTasks++

        // 调用钩子
        for _, hook := range m.hooks </span><span class="cov0" title="0">{
                if err := hook.OnTaskStart(taskStatus); err != nil </span><span class="cov0" title="0">{
                        taskStatus.Warnings = append(taskStatus.Warnings, fmt.Sprintf("Hook error: %v", err))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// UpdateProgress 更新任务进度
func (m *DefaultMonitor) UpdateProgress(taskID string, progress *recycler.TaskProgress) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        taskStatus, exists := m.tasks[taskID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("task %s not found", taskID)
        }</span>

        <span class="cov0" title="0">taskStatus.Progress = progress
        taskStatus.LastUpdate = time.Now()

        // 调用钩子
        for _, hook := range m.hooks </span><span class="cov0" title="0">{
                if err := hook.OnTaskProgress(taskStatus); err != nil </span><span class="cov0" title="0">{
                        taskStatus.Warnings = append(taskStatus.Warnings, fmt.Sprintf("Hook error: %v", err))
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// UpdateTaskStatus 更新任务状态
func (m *DefaultMonitor) UpdateTaskStatus(taskID string, status recycler.TaskStatus) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        taskStatus, exists := m.tasks[taskID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("task %s not found", taskID)
        }</span>

        <span class="cov0" title="0">taskStatus.Status = status
        taskStatus.LastUpdate = time.Now()

        // 立即持久化运行状态，确保跨进程可见
        if status == recycler.StatusRunning </span><span class="cov0" title="0">{
                go func() </span><span class="cov0" title="0">{
                        if err := m.PersistStatus(); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Warning: failed to persist running status: %v\n", err)
                        }</span>
                }()
        }

        <span class="cov0" title="0">return nil</span>
}

// CompleteTask 完成任务
func (m *DefaultMonitor) CompleteTask(taskID string, result *recycler.RecycleResult, err error) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        taskStatus, exists := m.tasks[taskID]
        if !exists </span><span class="cov0" title="0">{
                return fmt.Errorf("task %s not found", taskID)
        }</span>

        <span class="cov0" title="0">now := time.Now()
        taskStatus.CompletedAt = &amp;now
        taskStatus.LastUpdate = now
        taskStatus.Result = result

        if err != nil </span><span class="cov0" title="0">{
                taskStatus.Status = recycler.StatusFailed
                taskStatus.ErrorMessage = err.Error()
                m.stats.FailedTasks++

                // 调用失败钩子
                for _, hook := range m.hooks </span><span class="cov0" title="0">{
                        if hookErr := hook.OnTaskFailed(taskStatus, err); hookErr != nil </span><span class="cov0" title="0">{
                                taskStatus.Warnings = append(taskStatus.Warnings, fmt.Sprintf("Hook error: %v", hookErr))
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                taskStatus.Status = recycler.StatusCompleted
                m.stats.CompletedTasks++

                // 更新统计信息
                if result != nil </span><span class="cov0" title="0">{
                        m.stats.TotalReclaimedSpace += result.ReclaimedSpace
                        m.stats.TotalProcessedTables += result.ProcessedTables
                }</span>

                // 调用完成钩子
                <span class="cov0" title="0">for _, hook := range m.hooks </span><span class="cov0" title="0">{
                        if hookErr := hook.OnTaskComplete(taskStatus); hookErr != nil </span><span class="cov0" title="0">{
                                taskStatus.Warnings = append(taskStatus.Warnings, fmt.Sprintf("Hook error: %v", hookErr))
                        }</span>
                }
        }

        // 移动到历史记录
        <span class="cov0" title="0">m.addToHistory(taskStatus)
        delete(m.tasks, taskID)
        m.stats.ActiveTasks--

        return nil</span>
}

// GetTaskStatus 获取任务状态
func (m *DefaultMonitor) GetTaskStatus(taskID string) (*TaskStatus, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        if taskStatus, exists := m.tasks[taskID]; exists </span><span class="cov0" title="0">{
                // 返回副本以避免并发修改
                statusCopy := *taskStatus
                return &amp;statusCopy, nil
        }</span>

        // 在历史记录中查找
        <span class="cov0" title="0">for _, taskStatus := range m.taskHistory </span><span class="cov0" title="0">{
                if taskStatus.TaskID == taskID </span><span class="cov0" title="0">{
                        statusCopy := *taskStatus
                        return &amp;statusCopy, nil
                }</span>
        }

        <span class="cov0" title="0">return nil, fmt.Errorf("task %s not found", taskID)</span>
}

// ListActiveTasks 列出活跃任务
func (m *DefaultMonitor) ListActiveTasks() ([]*TaskStatus, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // 首先检查内存中的活跃任务
        tasks := make([]*TaskStatus, 0, len(m.tasks))
        for _, task := range m.tasks </span><span class="cov0" title="0">{
                taskCopy := *task
                tasks = append(tasks, &amp;taskCopy)
        }</span>
        
        // 如果内存中没有活跃任务，检查历史任务中是否有正在运行的任务
        // 这样可以支持跨进程查看正在运行的任务
        <span class="cov0" title="0">if len(tasks) == 0 </span><span class="cov0" title="0">{
                for _, task := range m.taskHistory </span><span class="cov0" title="0">{
                        // 只显示真正正在运行或等待中的任务，不包括已完成、失败或取消的任务
                        if task.Status == recycler.StatusRunning || task.Status == recycler.StatusPending </span><span class="cov0" title="0">{
                                // 检查任务是否还在合理的时间窗口内（避免显示过期的运行中任务）
                                if time.Since(task.LastUpdate) &lt; 10*time.Minute </span><span class="cov0" title="0">{
                                        taskCopy := *task
                                        tasks = append(tasks, &amp;taskCopy)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return tasks, nil</span>
}

// GetTaskHistory 获取任务历史
func (m *DefaultMonitor) GetTaskHistory(limit int) ([]*TaskStatus, error) <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        history := make([]*TaskStatus, 0)
        count := 0

        // 从最新的开始返回
        for i := len(m.taskHistory) - 1; i &gt;= 0 &amp;&amp; (limit == 0 || count &lt; limit); i-- </span><span class="cov0" title="0">{
                taskCopy := *m.taskHistory[i]
                history = append(history, &amp;taskCopy)
                count++
        }</span>

        <span class="cov0" title="0">return history, nil</span>
}

// GetStats 获取监控统计信息
func (m *DefaultMonitor) GetStats() *MonitorStats <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        stats := *m.stats
        stats.ActiveTasks = len(m.tasks)

        // 计算平均任务时长
        if m.stats.CompletedTasks &gt; 0 </span><span class="cov0" title="0">{
                var totalDuration time.Duration
                count := 0

                for _, task := range m.taskHistory </span><span class="cov0" title="0">{
                        if task.CompletedAt != nil &amp;&amp; task.StartedAt != nil </span><span class="cov0" title="0">{
                                totalDuration += task.CompletedAt.Sub(*task.StartedAt)
                                count++
                        }</span>
                }

                <span class="cov0" title="0">if count &gt; 0 </span><span class="cov0" title="0">{
                        stats.AverageTaskDuration = totalDuration / time.Duration(count)
                }</span>
        }

        <span class="cov0" title="0">return &amp;stats</span>
}

// RegisterHook 注册监控钩子
func (m *DefaultMonitor) RegisterHook(hook MonitorHook) error <span class="cov0" title="0">{
        m.mu.Lock()
        defer m.mu.Unlock()

        m.hooks = append(m.hooks, hook)
        return nil
}</span>

// PersistStatus 持久化状态到文件
func (m *DefaultMonitor) PersistStatus() error <span class="cov0" title="0">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        data := struct {
                Tasks       map[string]*TaskStatus `json:"tasks"`
                TaskHistory []*TaskStatus          `json:"task_history"`
                Stats       *MonitorStats          `json:"stats"`
                SavedAt     time.Time              `json:"saved_at"`
        }{
                Tasks:       m.tasks,
                TaskHistory: m.taskHistory,
                Stats:       m.stats,
                SavedAt:     time.Now(),
        }

        file, err := os.Create(m.statusFile)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create status file: %w", err)
        }</span>
        <span class="cov0" title="0">defer file.Close()

        encoder := json.NewEncoder(file)
        encoder.SetIndent("", "  ")
        if err := encoder.Encode(data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to encode status data: %w", err)
        }</span>

        <span class="cov0" title="0">m.stats.LastPersistTime = time.Now()
        return nil</span>
}

// LoadStatus 从文件加载状态
func (m *DefaultMonitor) LoadStatus() error <span class="cov0" title="0">{
        file, err := os.Open(m.statusFile)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil // 文件不存在，跳过加载
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to open status file: %w", err)</span>
        }
        <span class="cov0" title="0">defer file.Close()

        var data struct {
                Tasks       map[string]*TaskStatus `json:"tasks"`
                TaskHistory []*TaskStatus          `json:"task_history"`
                Stats       *MonitorStats          `json:"stats"`
                SavedAt     time.Time              `json:"saved_at"`
        }

        if err := json.NewDecoder(file).Decode(&amp;data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode status data: %w", err)
        }</span>

        <span class="cov0" title="0">m.mu.Lock()
        defer m.mu.Unlock()

        // 加载历史数据
        if data.TaskHistory != nil </span><span class="cov0" title="0">{
                m.taskHistory = data.TaskHistory
        }</span>

        // 加载统计信息
        <span class="cov0" title="0">if data.Stats != nil </span><span class="cov0" title="0">{
                m.stats = data.Stats
                // 重置活跃任务计数，因为重启后活跃任务会丢失
                m.stats.ActiveTasks = 0
        }</span>
        
        // 不加载活跃任务，因为重启后这些任务状态已经不可靠
        // 但可以通过 LoadActiveTasksForStatus() 方法专门为 status 命令加载

        <span class="cov0" title="0">return nil</span>
}

// LoadActiveTasksForStatus 专门为status命令加载活跃任务（支持跨进程监控）
func (m *DefaultMonitor) LoadActiveTasksForStatus() error <span class="cov0" title="0">{
        file, err := os.Open(m.statusFile)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil // 文件不存在，跳过加载
                }</span>
                <span class="cov0" title="0">return fmt.Errorf("failed to open status file: %w", err)</span>
        }
        <span class="cov0" title="0">defer file.Close()

        var data struct {
                Tasks       map[string]*TaskStatus `json:"tasks"`
                TaskHistory []*TaskStatus          `json:"task_history"`
                Stats       *MonitorStats          `json:"stats"`
                SavedAt     time.Time              `json:"saved_at"`
        }

        if err := json.NewDecoder(file).Decode(&amp;data); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to decode status data: %w", err)
        }</span>

        <span class="cov0" title="0">m.mu.Lock()
        defer m.mu.Unlock()

        // 关键修复：清空现有的内存任务，以持久化文件为准
        m.tasks = make(map[string]*TaskStatus)

        // 只从文件中加载真正活跃的任务
        if data.Tasks != nil </span><span class="cov0" title="0">{
                for taskID, task := range data.Tasks </span><span class="cov0" title="0">{
                        // 只加载状态为运行中或等待中且最近更新的任务
                        // 不加载已完成、失败或取消的任务
                        if (task.Status == recycler.StatusRunning || task.Status == recycler.StatusPending) &amp;&amp;
                                time.Since(task.LastUpdate) &lt; 5*time.Minute </span><span class="cov0" title="0">{
                                m.tasks[taskID] = task
                        }</span>
                }
        }
        
        // 同步统计信息：从文件中加载最新的统计数据
        <span class="cov0" title="0">if data.Stats != nil </span><span class="cov0" title="0">{
                // 保留uptime_start，但同步其他统计数据
                oldUptimeStart := m.stats.UptimeStart
                *m.stats = *data.Stats
                m.stats.UptimeStart = oldUptimeStart
        }</span>
        
        // 确保活跃任务计数准确
        <span class="cov0" title="0">m.stats.ActiveTasks = len(m.tasks)

        return nil</span>
}

// StartBackgroundPersistence 启动后台持久化
func (m *DefaultMonitor) StartBackgroundPersistence(ctx context.Context, interval time.Duration) error <span class="cov0" title="0">{
        ticker := time.NewTicker(interval)
        defer ticker.Stop()

        for </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ticker.C:<span class="cov0" title="0">
                        if err := m.PersistStatus(); err != nil </span><span class="cov0" title="0">{
                                // 记录错误但不中断服务
                                fmt.Printf("Failed to persist status: %v\n", err)
                        }</span>
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        // 最后一次保存
                        m.PersistStatus()
                        return ctx.Err()</span>
                }
        }
}

// addToHistory 添加到历史记录
func (m *DefaultMonitor) addToHistory(taskStatus *TaskStatus) <span class="cov0" title="0">{
        m.taskHistory = append(m.taskHistory, taskStatus)

        // 限制历史记录数量
        if len(m.taskHistory) &gt; m.maxHistoryRecords </span><span class="cov0" title="0">{
                // 删除最旧的记录
                copy(m.taskHistory, m.taskHistory[1:])
                m.taskHistory = m.taskHistory[:len(m.taskHistory)-1]
        }</span>
}

// Shutdown 优雅关闭监控器
func (m *DefaultMonitor) Shutdown() error <span class="cov0" title="0">{
        if m.cancel != nil </span><span class="cov0" title="0">{
                m.cancel()
        }</span>

        // 最终持久化
        <span class="cov0" title="0">return m.PersistStatus()</span>
}

// NotificationHook 通知钩子实现示例
type NotificationHook struct {
        webhookURL string
        enabled    bool
}

func NewNotificationHook(webhookURL string) *NotificationHook <span class="cov0" title="0">{
        return &amp;NotificationHook{
                webhookURL: webhookURL,
                enabled:    webhookURL != "",
        }
}</span>

func (h *NotificationHook) OnTaskStart(taskStatus *TaskStatus) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">message := fmt.Sprintf("🚀 Task %s started on %s",
                taskStatus.TaskID, taskStatus.Target.Node.GetHost())

        return h.sendNotification(message)</span>
}

func (h *NotificationHook) OnTaskProgress(taskStatus *TaskStatus) error <span class="cov0" title="0">{
        if !h.enabled || taskStatus.Progress == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // 只在特定进度点发送通知（避免过于频繁）
        <span class="cov0" title="0">if taskStatus.Progress.CompletedTables%10 == 0 </span><span class="cov0" title="0">{
                message := fmt.Sprintf("⏳ Task %s progress: %d/%d tables completed",
                        taskStatus.TaskID,
                        taskStatus.Progress.CompletedTables,
                        taskStatus.Progress.TotalTables)

                return h.sendNotification(message)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (h *NotificationHook) OnTaskComplete(taskStatus *TaskStatus) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">var reclaimedSpace int64
        var processedTables int
        if taskStatus.Result != nil </span><span class="cov0" title="0">{
                reclaimedSpace = taskStatus.Result.ReclaimedSpace
                processedTables = taskStatus.Result.ProcessedTables
        }</span>

        <span class="cov0" title="0">message := fmt.Sprintf("✅ Task %s completed: %d tables processed, %s reclaimed",
                taskStatus.TaskID, processedTables, formatBytes(reclaimedSpace))

        return h.sendNotification(message)</span>
}

func (h *NotificationHook) OnTaskFailed(taskStatus *TaskStatus, err error) error <span class="cov0" title="0">{
        if !h.enabled </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">message := fmt.Sprintf("❌ Task %s failed: %v", taskStatus.TaskID, err)

        return h.sendNotification(message)</span>
}

func (h *NotificationHook) sendNotification(message string) error <span class="cov0" title="0">{
        // 这里可以实现实际的通知发送逻辑
        // 例如发送到Slack、邮件、短信等
        fmt.Printf("Notification: %s\n", message)
        return nil
}</span>

// formatBytes 格式化字节数
func formatBytes(bytes int64) string <span class="cov0" title="0">{
        if bytes &lt; 1024 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", bytes)
        }</span> else<span class="cov0" title="0"> if bytes &lt; 1024*1024 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1f KB", float64(bytes)/1024)
        }</span> else<span class="cov0" title="0"> if bytes &lt; 1024*1024*1024 </span><span class="cov0" title="0">{
                return fmt.Sprintf("%.1f MB", float64(bytes)/(1024*1024))
        }</span> else<span class="cov0" title="0"> {
                return fmt.Sprintf("%.2f GB", float64(bytes)/(1024*1024*1024))
        }</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">package database

import (
        "context"
        "database/sql"
        "fmt"
        "time"

        "mysql_tablespace_recycling/pkg/config"

        _ "github.com/go-sql-driver/mysql"
        "go.uber.org/zap"
)

// Instance MySQL实例信息
type Instance struct {
        Host     string `json:"host"`
        Port     int    `json:"port"`
        User     string `json:"user"`
        Password string `json:"password"`
        Database string `json:"database"`
}

// String 返回实例的字符串表示
func (i *Instance) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%d", i.Host, i.Port)
}</span>

// DSN 生成数据库连接字符串
func (i *Instance) DSN() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s:%s@tcp(%s:%d)/%s?timeout=%s&amp;readTimeout=%s&amp;writeTimeout=%s&amp;parseTime=true",
                i.User, i.Password, i.Host, i.Port, i.Database, "10s", "30s", "30s")
}</span>

// Connection MySQL连接管理器
type Connection struct {
        instance *Instance
        db       *sql.DB
        logger   *zap.Logger
        config   *config.DatabaseConfig
}

// NewConnection 创建新的数据库连接
func NewConnection(instance *Instance, cfg *config.DatabaseConfig, logger *zap.Logger) (*Connection, error) <span class="cov0" title="0">{
        db, err := sql.Open("mysql", instance.DSN())
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open database connection: %w", err)
        }</span>

        // 配置连接池
        <span class="cov0" title="0">db.SetMaxIdleConns(cfg.MaxIdleConns)
        db.SetMaxOpenConns(cfg.MaxOpenConns)
        db.SetConnMaxLifetime(cfg.ConnMaxLifetime)

        // 测试连接
        ctx, cancel := context.WithTimeout(context.Background(), cfg.ConnTimeout)
        defer cancel()

        if err := db.PingContext(ctx); err != nil </span><span class="cov0" title="0">{
                db.Close()
                return nil, fmt.Errorf("failed to ping database: %w", err)
        }</span>

        <span class="cov0" title="0">conn := &amp;Connection{
                instance: instance,
                db:       db,
                logger:   logger,
                config:   cfg,
        }

        logger.Info("Database connection established", 
                zap.String("instance", instance.String()))

        return conn, nil</span>
}

// Close 关闭数据库连接
func (c *Connection) Close() error <span class="cov0" title="0">{
        if c.db != nil </span><span class="cov0" title="0">{
                c.logger.Info("Closing database connection", 
                        zap.String("instance", c.instance.String()))
                return c.db.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// GetDB 获取底层数据库连接
func (c *Connection) GetDB() *sql.DB <span class="cov0" title="0">{
        return c.db
}</span>

// GetInstance 获取实例信息
func (c *Connection) GetInstance() *Instance <span class="cov0" title="0">{
        return c.instance
}</span>

// QueryContext 执行查询语句
func (c *Connection) QueryContext(ctx context.Context, query string, args ...interface{}) (*sql.Rows, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                c.logger.Debug("Query executed",
                        zap.String("instance", c.instance.String()),
                        zap.String("query", query),
                        zap.Duration("duration", time.Since(start)))
        }</span>()

        <span class="cov0" title="0">queryCtx, cancel := context.WithTimeout(ctx, c.config.QueryTimeout)
        defer cancel()

        return c.db.QueryContext(queryCtx, query, args...)</span>
}

// QueryRowContext 执行查询单行语句
func (c *Connection) QueryRowContext(ctx context.Context, query string, args ...interface{}) *sql.Row <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                c.logger.Debug("QueryRow executed",
                        zap.String("instance", c.instance.String()),
                        zap.String("query", query),
                        zap.Duration("duration", time.Since(start)))
        }</span>()

        <span class="cov0" title="0">queryCtx, cancel := context.WithTimeout(ctx, c.config.QueryTimeout)
        defer cancel()

        return c.db.QueryRowContext(queryCtx, query, args...)</span>
}

// ExecContext 执行非查询语句
func (c *Connection) ExecContext(ctx context.Context, query string, args ...interface{}) (sql.Result, error) <span class="cov0" title="0">{
        start := time.Now()
        defer func() </span><span class="cov0" title="0">{
                c.logger.Debug("Exec executed",
                        zap.String("instance", c.instance.String()),
                        zap.String("query", query),
                        zap.Duration("duration", time.Since(start)))
        }</span>()

        <span class="cov0" title="0">execCtx, cancel := context.WithTimeout(ctx, c.config.QueryTimeout)
        defer cancel()

        return c.db.ExecContext(execCtx, query, args...)</span>
}

// TableInfo 表信息结构
type TableInfo struct {
        Schema     string `json:"schema"`
        Table      string `json:"table"`
        DataFree   int64  `json:"data_free"`   // 碎片大小
        DataLength int64  `json:"data_length"` // 数据大小
        Engine     string `json:"engine"`      // 存储引擎
}

// GetTableFragmentInfo 获取表碎片信息
func (c *Connection) GetTableFragmentInfo(ctx context.Context, schema string) ([]TableInfo, error) <span class="cov0" title="0">{
        query := `
                SELECT 
                        TABLE_SCHEMA,
                        TABLE_NAME,
                        COALESCE(DATA_FREE, 0) as DATA_FREE,
                        COALESCE(DATA_LENGTH, 0) as DATA_LENGTH,
                        ENGINE
                FROM information_schema.TABLES 
                WHERE TABLE_SCHEMA = ? 
                        AND ENGINE = 'InnoDB' 
                        AND TABLE_TYPE = 'BASE TABLE'
                        AND DATA_FREE &gt; 0
                ORDER BY DATA_FREE DESC`

        rows, err := c.QueryContext(ctx, query, schema)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query table fragment info: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        var tables []TableInfo
        for rows.Next() </span><span class="cov0" title="0">{
                var table TableInfo
                err := rows.Scan(&amp;table.Schema, &amp;table.Table, &amp;table.DataFree, &amp;table.DataLength, &amp;table.Engine)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan table info: %w", err)
                }</span>
                <span class="cov0" title="0">tables = append(tables, table)</span>
        }

        <span class="cov0" title="0">if err := rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("rows iteration error: %w", err)
        }</span>

        <span class="cov0" title="0">return tables, nil</span>
}

// IsReadOnly 检查实例是否为只读
func (c *Connection) IsReadOnly(ctx context.Context) (bool, error) <span class="cov0" title="0">{
        var readOnly string
        query := "SELECT @@read_only"
        
        err := c.QueryRowContext(ctx, query).Scan(&amp;readOnly)
        if err != nil </span><span class="cov0" title="0">{
                return false, fmt.Errorf("failed to check read_only status: %w", err)
        }</span>

        <span class="cov0" title="0">return readOnly == "1" || readOnly == "ON", nil</span>
}

// GetSlaveHosts 获取从库列表
func (c *Connection) GetSlaveHosts(ctx context.Context) ([]map[string]interface{}, error) <span class="cov0" title="0">{
        query := "SHOW SLAVE HOSTS"
        
        rows, err := c.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to show slave hosts: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        columns, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get columns: %w", err)
        }</span>

        <span class="cov0" title="0">var slaves []map[string]interface{}
        for rows.Next() </span><span class="cov0" title="0">{
                values := make([]interface{}, len(columns))
                valuePtrs := make([]interface{}, len(columns))
                for i := range values </span><span class="cov0" title="0">{
                        valuePtrs[i] = &amp;values[i]
                }</span>

                <span class="cov0" title="0">if err := rows.Scan(valuePtrs...); err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan slave host: %w", err)
                }</span>

                <span class="cov0" title="0">slave := make(map[string]interface{})
                for i, col := range columns </span><span class="cov0" title="0">{
                        slave[col] = values[i]
                }</span>
                <span class="cov0" title="0">slaves = append(slaves, slave)</span>
        }

        <span class="cov0" title="0">return slaves, nil</span>
}

// GetSlaveStatus 获取从库状态
func (c *Connection) GetSlaveStatus(ctx context.Context) (map[string]interface{}, error) <span class="cov0" title="0">{
        query := "SHOW SLAVE STATUS"
        
        rows, err := c.QueryContext(ctx, query)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to show slave status: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()

        if !rows.Next() </span><span class="cov0" title="0">{
                return nil, nil // 没有从库状态，说明不是从库
        }</span>

        <span class="cov0" title="0">columns, err := rows.Columns()
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to get columns: %w", err)
        }</span>

        <span class="cov0" title="0">values := make([]interface{}, len(columns))
        valuePtrs := make([]interface{}, len(columns))
        for i := range values </span><span class="cov0" title="0">{
                valuePtrs[i] = &amp;values[i]
        }</span>

        <span class="cov0" title="0">if err := rows.Scan(valuePtrs...); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan slave status: %w", err)
        }</span>

        <span class="cov0" title="0">status := make(map[string]interface{})
        for i, col := range columns </span><span class="cov0" title="0">{
                status[col] = values[i]
        }</span>

        <span class="cov0" title="0">return status, nil</span>
}</pre>
		
		<pre class="file" id="file16" style="display: none">package logger

import (
        "fmt"
        "io"
        "log"
        "os"
        "strings"
)

// LogLevel 日志级别
type LogLevel int

const (
        DEBUG LogLevel = iota
        INFO
        WARN
        ERROR
)

// String 返回日志级别的字符串表示
func (l LogLevel) String() string <span class="cov0" title="0">{
        switch l </span>{
        case DEBUG:<span class="cov0" title="0">
                return "DEBUG"</span>
        case INFO:<span class="cov0" title="0">
                return "INFO"</span>
        case WARN:<span class="cov0" title="0">
                return "WARN"</span>
        case ERROR:<span class="cov0" title="0">
                return "ERROR"</span>
        default:<span class="cov0" title="0">
                return "UNKNOWN"</span>
        }
}

// Logger 简单的日志接口
type Logger interface {
        Debug(msg string, args ...interface{})
        Info(msg string, args ...interface{})
        Warn(msg string, args ...interface{})
        Error(msg string, args ...interface{})
        SetLevel(level LogLevel)
        SetOutput(w io.Writer)
}

// DefaultLogger 默认日志实现
type DefaultLogger struct {
        level  LogLevel
        logger *log.Logger
}

// NewLogger 创建新的日志器
func NewLogger(level LogLevel, output io.Writer) Logger <span class="cov0" title="0">{
        if output == nil </span><span class="cov0" title="0">{
                output = os.Stdout
        }</span>
        
        <span class="cov0" title="0">return &amp;DefaultLogger{
                level:  level,
                logger: log.New(output, "", log.LstdFlags),
        }</span>
}

// NewLoggerFromString 从字符串创建日志器
func NewLoggerFromString(levelStr string, output io.Writer) Logger <span class="cov0" title="0">{
        level := parseLogLevel(levelStr)
        return NewLogger(level, output)
}</span>

// parseLogLevel 解析日志级别字符串
func parseLogLevel(levelStr string) LogLevel <span class="cov0" title="0">{
        switch strings.ToUpper(levelStr) </span>{
        case "DEBUG":<span class="cov0" title="0">
                return DEBUG</span>
        case "INFO":<span class="cov0" title="0">
                return INFO</span>
        case "WARN", "WARNING":<span class="cov0" title="0">
                return WARN</span>
        case "ERROR":<span class="cov0" title="0">
                return ERROR</span>
        default:<span class="cov0" title="0">
                return INFO</span>
        }
}

// SetLevel 设置日志级别
func (l *DefaultLogger) SetLevel(level LogLevel) <span class="cov0" title="0">{
        l.level = level
}</span>

// SetOutput 设置输出
func (l *DefaultLogger) SetOutput(w io.Writer) <span class="cov0" title="0">{
        l.logger.SetOutput(w)
}</span>

// Debug 输出调试日志
func (l *DefaultLogger) Debug(msg string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= DEBUG </span><span class="cov0" title="0">{
                l.log(DEBUG, msg, args...)
        }</span>
}

// Info 输出信息日志
func (l *DefaultLogger) Info(msg string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= INFO </span><span class="cov0" title="0">{
                l.log(INFO, msg, args...)
        }</span>
}

// Warn 输出警告日志
func (l *DefaultLogger) Warn(msg string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= WARN </span><span class="cov0" title="0">{
                l.log(WARN, msg, args...)
        }</span>
}

// Error 输出错误日志
func (l *DefaultLogger) Error(msg string, args ...interface{}) <span class="cov0" title="0">{
        if l.level &lt;= ERROR </span><span class="cov0" title="0">{
                l.log(ERROR, msg, args...)
        }</span>
}

// log 内部日志方法
func (l *DefaultLogger) log(level LogLevel, msg string, args ...interface{}) <span class="cov0" title="0">{
        prefix := fmt.Sprintf("[%s] ", level.String())
        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                msg = fmt.Sprintf(msg, args...)
        }</span>
        <span class="cov0" title="0">l.logger.Print(prefix + msg)</span>
}

// 全局日志器实例
var globalLogger Logger = NewLogger(INFO, os.Stdout)

// SetGlobalLogger 设置全局日志器
func SetGlobalLogger(logger Logger) <span class="cov0" title="0">{
        globalLogger = logger
}</span>

// GetGlobalLogger 获取全局日志器
func GetGlobalLogger() Logger <span class="cov0" title="0">{
        return globalLogger
}</span>

// 全局日志函数
func Debug(msg string, args ...interface{}) <span class="cov0" title="0">{
        globalLogger.Debug(msg, args...)
}</span>

func Info(msg string, args ...interface{}) <span class="cov0" title="0">{
        globalLogger.Info(msg, args...)
}</span>

func Warn(msg string, args ...interface{}) <span class="cov0" title="0">{
        globalLogger.Warn(msg, args...)
}</span>

func Error(msg string, args ...interface{}) <span class="cov0" title="0">{
        globalLogger.Error(msg, args...)
}</pre>
		
		<pre class="file" id="file17" style="display: none">package recycler

import (
        "context"
        "database/sql"
        "fmt"
        "sort"
        "strings"
        "time"

        "mysql_tablespace_recycling/pkg/database"
)

// DefaultFragmentationAnalyzer 默认碎片分析器实现
type DefaultFragmentationAnalyzer struct {
        connectionFactory database.ConnectionFactory
}

// ConnectionFactory 连接工厂接口 - 使用通用接口
type ConnectionFactory = database.ConnectionFactory

// DBConnection 数据库连接接口 - 使用通用接口
type DBConnection = database.DBConnection

// NodeConfigInterface 节点配置接口 - 使用通用接口
type NodeConfigInterface = database.NodeConfigInterface

// NewFragmentationAnalyzer 创建碎片分析器
func NewFragmentationAnalyzer(connectionFactory ConnectionFactory) FragmentationAnalyzer <span class="cov0" title="0">{
        return &amp;DefaultFragmentationAnalyzer{
                connectionFactory: connectionFactory,
        }
}</span>

// AnalyzeFragmentation 分析表空间碎片
func (a *DefaultFragmentationAnalyzer) AnalyzeFragmentation(ctx context.Context, nodeConfig NodeConfigInterface, options *FragmentationAnalysisOptions) (*FragmentationReport, error) <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                options = GetDefaultAnalysisOptions()
        }</span>
        
        <span class="cov0" title="0">conn, err := a.connectionFactory.CreateConnection(nodeConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to %s: %w", nodeConfig.NodeKey(), err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()
        
        report := &amp;FragmentationReport{
                NodeHost:        nodeConfig.GetHost(),
                NodePort:        nodeConfig.GetPort(),
                AnalysisTime:    time.Now(),
                AnalysisOptions: options,
        }
        
        // 构建查询SQL
        query, args := a.buildFragmentationQuery(options)
        
        // 执行查询
        rows, err := conn.Query(query, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query table information: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        
        // 解析结果
        var allTables []*TableFragmentation
        var fragmentedTables []*TableFragmentation
        
        for rows.Next() </span><span class="cov0" title="0">{
                table, err := a.scanTableFragmentation(rows)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("failed to scan table row: %w", err)
                }</span>
                
                // 计算碎片化指标
                <span class="cov0" title="0">table.CalculateFragmentationMetrics()
                allTables = append(allTables, table)
                
                // 检查是否需要整理
                if table.IsFragmented(options) </span><span class="cov0" title="0">{
                        fragmentedTables = append(fragmentedTables, table)
                }</span>
                
                // 更新统计信息
                <span class="cov0" title="0">report.TotalDataSize += table.DataLength
                report.TotalIndexSize += table.IndexLength
                report.TotalFragmentSize += table.DataFree</span>
        }
        
        <span class="cov0" title="0">if err = rows.Err(); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error iterating table rows: %w", err)
        }</span>
        
        // 排序碎片化表
        <span class="cov0" title="0">a.sortFragmentedTables(fragmentedTables, options)
        
        // 应用限制
        if options.Limit &gt; 0 &amp;&amp; len(fragmentedTables) &gt; options.Limit </span><span class="cov0" title="0">{
                fragmentedTables = fragmentedTables[:options.Limit]
        }</span>
        
        // 填充报告
        <span class="cov0" title="0">report.TotalTables = len(allTables)
        report.FragmentedTables = fragmentedTables
        report.EstimatedReclaimableSpace = a.calculateReclaimableSpace(fragmentedTables)
        
        if len(fragmentedTables) &gt; 0 </span><span class="cov0" title="0">{
                report.AverageFragmentRatio = float64(report.TotalFragmentSize) / float64(report.TotalDataSize+report.TotalIndexSize)
                report.LargestFragmentTable = a.findLargestFragmentTable(fragmentedTables)
                report.HighestRatioTable = a.findHighestRatioTable(fragmentedTables)
        }</span>
        
        <span class="cov0" title="0">report.RecommendedActions = a.generateRecommendations(report)
        
        return report, nil</span>
}

// GetTableFragmentation 获取单个表的碎片信息
func (a *DefaultFragmentationAnalyzer) GetTableFragmentation(ctx context.Context, nodeConfig NodeConfigInterface, schema, tableName string) (*TableFragmentation, error) <span class="cov0" title="0">{
        conn, err := a.connectionFactory.CreateConnection(nodeConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect to %s: %w", nodeConfig.NodeKey(), err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()
        
        query := `
                SELECT 
                        table_schema, table_name, engine, table_rows, avg_row_length,
                        data_length, max_data_length, index_length, data_free,
                        auto_increment, create_time, update_time, check_time,
                        table_collation, checksum, create_options, table_comment
                FROM information_schema.tables
                WHERE table_schema = ? AND table_name = ? AND table_type = 'BASE TABLE'
        `
        
        rows, err := conn.Query(query, schema, tableName)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to query table information: %w", err)
        }</span>
        <span class="cov0" title="0">defer rows.Close()
        
        if !rows.Next() </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("table %s.%s not found", schema, tableName)
        }</span>
        
        <span class="cov0" title="0">table, err := a.scanTableFragmentation(rows)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to scan table row: %w", err)
        }</span>
        
        <span class="cov0" title="0">table.CalculateFragmentationMetrics()
        return table, nil</span>
}

// GetSchemaFragmentation 获取指定数据库的碎片信息
func (a *DefaultFragmentationAnalyzer) GetSchemaFragmentation(ctx context.Context, nodeConfig NodeConfigInterface, schema string, options *FragmentationAnalysisOptions) ([]*TableFragmentation, error) <span class="cov0" title="0">{
        if options == nil </span><span class="cov0" title="0">{
                options = GetDefaultAnalysisOptions()
        }</span>
        
        // 临时修改选项，只查询指定数据库
        <span class="cov0" title="0">tempOptions := *options
        tempOptions.IncludeSchemas = []string{schema}
        tempOptions.ExcludeSchemas = nil
        
        report, err := a.AnalyzeFragmentation(ctx, nodeConfig, &amp;tempOptions)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        <span class="cov0" title="0">return report.FragmentedTables, nil</span>
}

// EstimateReclaimBenefit 估算回收收益
func (a *DefaultFragmentationAnalyzer) EstimateReclaimBenefit(fragmentation *TableFragmentation) (*ReclaimBenefit, error) <span class="cov8" title="1">{
        benefit := &amp;ReclaimBenefit{
                EstimatedReclaimedSpace: fragmentation.DataFree,
                Benefits:               []string{},
                Risks:                  []string{},
        }
        
        // 估算时间成本（基于表大小）
        totalSizeMB := fragmentation.TotalSize / (1024 * 1024)
        if totalSizeMB &lt; 100 </span><span class="cov8" title="1">{
                benefit.EstimatedTimeCost = 1 * time.Minute
        }</span> else<span class="cov8" title="1"> if totalSizeMB &lt; 1000 </span><span class="cov0" title="0">{
                benefit.EstimatedTimeCost = time.Duration(totalSizeMB/10) * time.Minute
        }</span> else<span class="cov8" title="1"> {
                benefit.EstimatedTimeCost = time.Duration(totalSizeMB/5) * time.Minute
        }</span>
        
        // 计算优先级（基于碎片大小和比例）
        <span class="cov8" title="1">sizeScore := int(fragmentation.DataFree / (100 * 1024 * 1024)) // 每100MB得1分
        ratioScore := int(fragmentation.FragmentRatio * 100)           // 百分比得分
        benefit.Priority = sizeScore + ratioScore
        
        // 评估风险级别
        if fragmentation.TotalSize &gt; 10*1024*1024*1024 </span><span class="cov8" title="1">{ // 超过10GB
                benefit.RiskLevel = RiskHigh
                benefit.Risks = append(benefit.Risks, "Large table size may cause extended table lock time")
        }</span> else<span class="cov8" title="1"> if fragmentation.TotalSize &gt; 1*1024*1024*1024 </span><span class="cov0" title="0">{ // 超过1GB
                benefit.RiskLevel = RiskMedium
                benefit.Risks = append(benefit.Risks, "Medium table size requires careful scheduling")
        }</span> else<span class="cov8" title="1"> {
                benefit.RiskLevel = RiskLow
        }</span>
        
        // 添加收益说明
        <span class="cov8" title="1">if fragmentation.FragmentRatio &gt; 0.2 </span><span class="cov8" title="1">{
                benefit.Benefits = append(benefit.Benefits, fmt.Sprintf("High fragmentation ratio (%.1f%%) indicates significant space waste", fragmentation.FragmentRatio*100))
        }</span>
        
        <span class="cov8" title="1">if fragmentation.DataFree &gt; 500*1024*1024 </span><span class="cov8" title="1">{
                benefit.Benefits = append(benefit.Benefits, fmt.Sprintf("Large fragment size (%s) can be reclaimed", formatBytes(fragmentation.DataFree)))
        }</span>
        
        // 生成建议
        <span class="cov8" title="1">if benefit.Priority &gt; 50 &amp;&amp; benefit.RiskLevel != RiskHigh </span><span class="cov0" title="0">{
                benefit.Recommendation = "Highly recommended for optimization"
        }</span> else<span class="cov8" title="1"> if benefit.Priority &gt; 20 </span><span class="cov8" title="1">{
                benefit.Recommendation = "Recommended for optimization during maintenance window"
        }</span> else<span class="cov0" title="0"> {
                benefit.Recommendation = "Consider optimization if other factors permit"
        }</span>
        
        <span class="cov8" title="1">return benefit, nil</span>
}

// buildFragmentationQuery 构建碎片查询SQL
func (a *DefaultFragmentationAnalyzer) buildFragmentationQuery(options *FragmentationAnalysisOptions) (string, []interface{}) <span class="cov0" title="0">{
        query := `
                SELECT 
                        table_schema, table_name, engine, table_rows, avg_row_length,
                        data_length, max_data_length, index_length, data_free,
                        auto_increment, create_time, update_time, check_time,
                        table_collation, checksum, create_options, table_comment
                FROM information_schema.tables
                WHERE table_type = 'BASE TABLE'
        `
        
        var conditions []string
        var args []interface{}
        
        // 包含数据库条件
        if len(options.IncludeSchemas) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := strings.Repeat("?,", len(options.IncludeSchemas))
                placeholders = placeholders[:len(placeholders)-1]
                conditions = append(conditions, fmt.Sprintf("table_schema IN (%s)", placeholders))
                for _, schema := range options.IncludeSchemas </span><span class="cov0" title="0">{
                        args = append(args, schema)
                }</span>
        }
        
        // 排除数据库条件
        <span class="cov0" title="0">if len(options.ExcludeSchemas) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := strings.Repeat("?,", len(options.ExcludeSchemas))
                placeholders = placeholders[:len(placeholders)-1]
                conditions = append(conditions, fmt.Sprintf("table_schema NOT IN (%s)", placeholders))
                for _, schema := range options.ExcludeSchemas </span><span class="cov0" title="0">{
                        args = append(args, schema)
                }</span>
        }
        
        // 存储引擎条件
        <span class="cov0" title="0">if len(options.SupportedEngines) &gt; 0 </span><span class="cov0" title="0">{
                placeholders := strings.Repeat("?,", len(options.SupportedEngines))
                placeholders = placeholders[:len(placeholders)-1]
                conditions = append(conditions, fmt.Sprintf("engine IN (%s)", placeholders))
                for _, engine := range options.SupportedEngines </span><span class="cov0" title="0">{
                        args = append(args, engine)
                }</span>
        }
        
        // 表大小条件
        <span class="cov0" title="0">if options.MinTableSize &gt; 0 </span><span class="cov0" title="0">{
                conditions = append(conditions, "(data_length + index_length) &gt;= ?")
                args = append(args, options.MinTableSize)
        }</span>
        
        <span class="cov0" title="0">if options.MaxTableSize &gt; 0 </span><span class="cov0" title="0">{
                conditions = append(conditions, "(data_length + index_length) &lt;= ?")
                args = append(args, options.MaxTableSize)
        }</span>
        
        // 添加WHERE条件
        <span class="cov0" title="0">if len(conditions) &gt; 0 </span><span class="cov0" title="0">{
                query += " AND " + strings.Join(conditions, " AND ")
        }</span>
        
        // 添加排序
        <span class="cov0" title="0">orderBy := "data_free DESC" // 默认按碎片大小降序
        if options.SortBy != "" </span><span class="cov0" title="0">{
                switch options.SortBy </span>{
                case "fragment_size":<span class="cov0" title="0">
                        orderBy = "data_free"</span>
                case "fragment_ratio":<span class="cov0" title="0">
                        orderBy = "data_free / GREATEST(data_length + index_length, 1)"</span>
                case "total_size":<span class="cov0" title="0">
                        orderBy = "data_length + index_length"</span>
                case "table_name":<span class="cov0" title="0">
                        orderBy = "table_schema, table_name"</span>
                default:<span class="cov0" title="0">
                        orderBy = "data_free"</span>
                }
                
                <span class="cov0" title="0">if options.SortOrder == "asc" </span><span class="cov0" title="0">{
                        orderBy += " ASC"
                }</span> else<span class="cov0" title="0"> {
                        orderBy += " DESC"
                }</span>
        }
        <span class="cov0" title="0">query += " ORDER BY " + orderBy
        
        return query, args</span>
}

// scanTableFragmentation 扫描表碎片信息
func (a *DefaultFragmentationAnalyzer) scanTableFragmentation(rows *sql.Rows) (*TableFragmentation, error) <span class="cov0" title="0">{
        var table TableFragmentation
        var autoIncrement sql.NullInt64
        var createTime sql.NullTime
        var updateTime sql.NullTime
        var checkTime sql.NullTime
        var checksum sql.NullInt64
        
        err := rows.Scan(
                &amp;table.Schema, &amp;table.TableName, &amp;table.Engine, &amp;table.TableRows, &amp;table.AvgRowLength,
                &amp;table.DataLength, &amp;table.MaxDataLength, &amp;table.IndexLength, &amp;table.DataFree,
                &amp;autoIncrement, &amp;createTime, &amp;updateTime, &amp;checkTime,
                &amp;table.TableCollation, &amp;checksum, &amp;table.CreateOptions, &amp;table.TableComment,
        )
        
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        
        // 处理可空字段
        <span class="cov0" title="0">if autoIncrement.Valid </span><span class="cov0" title="0">{
                table.AutoIncrement = &amp;autoIncrement.Int64
        }</span>
        <span class="cov0" title="0">if createTime.Valid </span><span class="cov0" title="0">{
                table.CreateTime = &amp;createTime.Time
        }</span>
        <span class="cov0" title="0">if updateTime.Valid </span><span class="cov0" title="0">{
                table.UpdateTime = &amp;updateTime.Time
        }</span>
        <span class="cov0" title="0">if checkTime.Valid </span><span class="cov0" title="0">{
                table.CheckTime = &amp;checkTime.Time
        }</span>
        <span class="cov0" title="0">if checksum.Valid </span><span class="cov0" title="0">{
                table.Checksum = &amp;checksum.Int64
        }</span>
        
        <span class="cov0" title="0">return &amp;table, nil</span>
}

// sortFragmentedTables 排序碎片化表
func (a *DefaultFragmentationAnalyzer) sortFragmentedTables(tables []*TableFragmentation, options *FragmentationAnalysisOptions) <span class="cov0" title="0">{
        sort.Slice(tables, func(i, j int) bool </span><span class="cov0" title="0">{
                var less bool
                switch options.SortBy </span>{
                case "fragment_ratio":<span class="cov0" title="0">
                        less = tables[i].FragmentRatio &gt; tables[j].FragmentRatio</span>
                case "total_size":<span class="cov0" title="0">
                        less = tables[i].TotalSize &gt; tables[j].TotalSize</span>
                case "table_name":<span class="cov0" title="0">
                        less = tables[i].Schema &lt; tables[j].Schema || 
                                   (tables[i].Schema == tables[j].Schema &amp;&amp; tables[i].TableName &lt; tables[j].TableName)</span>
                default:<span class="cov0" title="0"> // fragment_size
                        less = tables[i].DataFree &gt; tables[j].DataFree</span>
                }
                
                <span class="cov0" title="0">if options.SortOrder == "asc" </span><span class="cov0" title="0">{
                        return !less
                }</span>
                <span class="cov0" title="0">return less</span>
        })
}

// calculateReclaimableSpace 计算可回收空间
func (a *DefaultFragmentationAnalyzer) calculateReclaimableSpace(tables []*TableFragmentation) int64 <span class="cov0" title="0">{
        var total int64
        for _, table := range tables </span><span class="cov0" title="0">{
                // 通常可以回收80-90%的碎片空间
                total += int64(float64(table.DataFree) * 0.85)
        }</span>
        <span class="cov0" title="0">return total</span>
}

// findLargestFragmentTable 找到碎片最大的表
func (a *DefaultFragmentationAnalyzer) findLargestFragmentTable(tables []*TableFragmentation) *TableFragmentation <span class="cov0" title="0">{
        if len(tables) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">largest := tables[0]
        for _, table := range tables[1:] </span><span class="cov0" title="0">{
                if table.DataFree &gt; largest.DataFree </span><span class="cov0" title="0">{
                        largest = table
                }</span>
        }
        <span class="cov0" title="0">return largest</span>
}

// findHighestRatioTable 找到碎片率最高的表
func (a *DefaultFragmentationAnalyzer) findHighestRatioTable(tables []*TableFragmentation) *TableFragmentation <span class="cov0" title="0">{
        if len(tables) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        
        <span class="cov0" title="0">highest := tables[0]
        for _, table := range tables[1:] </span><span class="cov0" title="0">{
                if table.FragmentRatio &gt; highest.FragmentRatio </span><span class="cov0" title="0">{
                        highest = table
                }</span>
        }
        <span class="cov0" title="0">return highest</span>
}

// generateRecommendations 生成优化建议
func (a *DefaultFragmentationAnalyzer) generateRecommendations(report *FragmentationReport) []string <span class="cov0" title="0">{
        var recommendations []string
        
        if len(report.FragmentedTables) == 0 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "No fragmented tables found, database is well optimized")
                return recommendations
        }</span>
        
        // 基于碎片数量的建议
        <span class="cov0" title="0">if len(report.FragmentedTables) &gt; 20 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "High number of fragmented tables detected, consider scheduling regular maintenance")
        }</span>
        
        // 基于碎片大小的建议
        <span class="cov0" title="0">if report.TotalFragmentSize &gt; 1024*1024*1024 </span><span class="cov0" title="0">{ // &gt; 1GB
                recommendations = append(recommendations, "Significant fragmentation detected (&gt;1GB), optimization will improve performance")
        }</span>
        
        // 基于碎片率的建议
        <span class="cov0" title="0">if report.AverageFragmentRatio &gt; 0.2 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "High average fragmentation ratio (&gt;20%), urgent optimization recommended")
        }</span> else<span class="cov0" title="0"> if report.AverageFragmentRatio &gt; 0.1 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Moderate fragmentation detected, optimization recommended during maintenance window")
        }</span>
        
        // 针对最大碎片表的建议
        <span class="cov0" title="0">if report.LargestFragmentTable != nil &amp;&amp; report.LargestFragmentTable.DataFree &gt; 500*1024*1024 </span><span class="cov0" title="0">{
                recommendations = append(recommendations, 
                        fmt.Sprintf("Table %s.%s has %s fragmented space, high priority for optimization",
                                report.LargestFragmentTable.Schema, 
                                report.LargestFragmentTable.TableName,
                                formatBytes(report.LargestFragmentTable.DataFree)))
        }</span>
        
        // 运行时间建议
        <span class="cov0" title="0">totalEstimatedTime := time.Duration(0)
        for _, table := range report.FragmentedTables </span><span class="cov0" title="0">{
                benefit, _ := a.EstimateReclaimBenefit(table)
                if benefit != nil </span><span class="cov0" title="0">{
                        totalEstimatedTime += benefit.EstimatedTimeCost
                }</span>
        }
        
        <span class="cov0" title="0">if totalEstimatedTime &gt; 2*time.Hour </span><span class="cov0" title="0">{
                recommendations = append(recommendations, "Total optimization time exceeds 2 hours, consider splitting into multiple maintenance windows")
        }</span>
        
        <span class="cov0" title="0">return recommendations</span>
}</pre>
		
		<pre class="file" id="file18" style="display: none">package recycler

import (
        "context"
        "database/sql"
        "fmt"
        "sync"
        "time"

        "mysql_tablespace_recycling/cluster"
)

// RecycleMode 回收模式
type RecycleMode int

const (
        ModeIndependent RecycleMode = 1 // 独立节点模式 (sql_log_bin=OFF)
        ModeReplication RecycleMode = 2 // 复制同步模式 (sql_log_bin=ON)
)

// RecycleTask 回收任务
type RecycleTask struct {
        ID        string                `json:"id"`
        Target    *RecycleTarget        `json:"target"`
        Tables    []*TableFragmentation `json:"tables"`
        Priority  int                   `json:"priority"`
        CreatedAt time.Time             `json:"created_at"`
        Status    TaskStatus            `json:"status"`
        Progress  *TaskProgress         `json:"progress,omitempty"`
        Result    *RecycleResult        `json:"result,omitempty"`
        Error     string                `json:"error,omitempty"`
}

// RecycleTarget 回收目标配置
type RecycleTarget struct {
        Node          *cluster.NodeConfig `json:"node"`
        Mode          RecycleMode         `json:"mode"`
        Databases     []string            `json:"databases,omitempty"`
        Tables        []string            `json:"tables,omitempty"`
        ExcludeDBs    []string            `json:"exclude_dbs,omitempty"`
        ExcludeTables []string            `json:"exclude_tables,omitempty"`
        Threshold     int64               `json:"threshold"`
        Concurrency   int                 `json:"concurrency"`
        DryRun        bool                `json:"dry_run"`
        SafetyChecks  bool                `json:"safety_checks"`
}

// TaskStatus 任务状态
type TaskStatus int

const (
        StatusPending TaskStatus = iota
        StatusRunning
        StatusCompleted
        StatusFailed
        StatusCancelled
        StatusPaused
)

func (s TaskStatus) String() string <span class="cov0" title="0">{
        switch s </span>{
        case StatusPending:<span class="cov0" title="0">
                return "pending"</span>
        case StatusRunning:<span class="cov0" title="0">
                return "running"</span>
        case StatusCompleted:<span class="cov0" title="0">
                return "completed"</span>
        case StatusFailed:<span class="cov0" title="0">
                return "failed"</span>
        case StatusCancelled:<span class="cov0" title="0">
                return "cancelled"</span>
        case StatusPaused:<span class="cov0" title="0">
                return "paused"</span>
        default:<span class="cov0" title="0">
                return "unknown"</span>
        }
}

// TaskProgress 任务进度
type TaskProgress struct {
        TaskID             string        `json:"task_id"`
        TotalTables        int           `json:"total_tables"`
        CompletedTables    int           `json:"completed_tables"`
        CurrentTable       string        `json:"current_table"`
        CurrentTableSize   int64         `json:"current_table_size"`
        ProcessedSize      int64         `json:"processed_size"`
        ReclaimedSpace     int64         `json:"reclaimed_space"`
        EstimatedRemaining time.Duration `json:"estimated_remaining"`
        StartTime          time.Time     `json:"start_time"`
        LastUpdate         time.Time     `json:"last_update"`
        ErrorCount         int           `json:"error_count"`
}

// RecycleResult 回收结果
type RecycleResult struct {
        TaskID           string                `json:"task_id"`
        ProcessedTables  int                   `json:"processed_tables"`
        SuccessfulTables int                   `json:"successful_tables"`
        FailedTables     int                   `json:"failed_tables"`
        SkippedTables    int                   `json:"skipped_tables"`
        ReclaimedSpace   int64                 `json:"reclaimed_space"`
        TotalTime        time.Duration         `json:"total_time"`
        TableResults     []*TableRecycleResult `json:"table_results"`
        Errors           []string              `json:"errors,omitempty"`
        Warnings         []string              `json:"warnings,omitempty"`
}

// TableRecycleResult 单个表的回收结果
type TableRecycleResult struct {
        Schema         string        `json:"schema"`
        TableName      string        `json:"table_name"`
        Status         string        `json:"status"`
        BeforeSize     int64         `json:"before_size"`
        AfterSize      int64         `json:"after_size"`
        ReclaimedSpace int64         `json:"reclaimed_space"`
        Duration       time.Duration `json:"duration"`
        Error          string        `json:"error,omitempty"`
}

// TablespaceRecycler 表空间回收器接口
type TablespaceRecycler interface {
        // ExecuteRecycle 执行表空间回收任务
        ExecuteRecycle(ctx context.Context, task *RecycleTask) (*RecycleResult, error)

        // RecycleTable 回收单个表
        RecycleTable(ctx context.Context, target *RecycleTarget, table *TableFragmentation) (*TableRecycleResult, error)

        // EstimateRecycleTime 估算回收时间
        EstimateRecycleTime(target *RecycleTarget) (time.Duration, error)

        // ValidateTarget 验证回收目标
        ValidateTarget(ctx context.Context, target *RecycleTarget) error
}

// DefaultTablespaceRecycler 默认表空间回收器实现
type DefaultTablespaceRecycler struct {
        connectionFactory ConnectionFactory
        analyzer          FragmentationAnalyzer
        validator         MasterValidator
        mu                sync.RWMutex
        activeTasks       map[string]*RecycleTask
        progressCallbacks []ProgressCallback
}

// MasterValidator 主节点验证器接口
type MasterValidator interface {
        ValidateMasterSafety(ctx context.Context, node NodeConfigInterface) error
}

// ProgressCallback 进度回调函数类型
type ProgressCallback func(progress *TaskProgress)

// NewTablespaceRecycler 创建表空间回收器
func NewTablespaceRecycler(
        factory ConnectionFactory,
        analyzer FragmentationAnalyzer,
        validator MasterValidator,
) TablespaceRecycler <span class="cov0" title="0">{
        return &amp;DefaultTablespaceRecycler{
                connectionFactory: factory,
                analyzer:          analyzer,
                validator:         validator,
                activeTasks:       make(map[string]*RecycleTask),
        }
}</span>

// RegisterProgressCallback 注册进度回调
func (r *DefaultTablespaceRecycler) RegisterProgressCallback(callback ProgressCallback) <span class="cov0" title="0">{
        r.mu.Lock()
        defer r.mu.Unlock()
        r.progressCallbacks = append(r.progressCallbacks, callback)
}</span>

// ExecuteRecycle 执行表空间回收任务
func (r *DefaultTablespaceRecycler) ExecuteRecycle(ctx context.Context, task *RecycleTask) (*RecycleResult, error) <span class="cov0" title="0">{
        // 验证任务
        if err := r.ValidateTarget(ctx, task.Target); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("target validation failed: %w", err)
        }</span>

        // 注册活跃任务
        <span class="cov0" title="0">r.mu.Lock()
        r.activeTasks[task.ID] = task
        r.mu.Unlock()

        // 任务完成后清理
        defer func() </span><span class="cov0" title="0">{
                r.mu.Lock()
                delete(r.activeTasks, task.ID)
                r.mu.Unlock()
        }</span>()

        // 初始化任务状态
        <span class="cov0" title="0">task.Status = StatusRunning
        task.Progress = &amp;TaskProgress{
                TaskID:      task.ID,
                TotalTables: len(task.Tables),
                StartTime:   time.Now(),
                LastUpdate:  time.Now(),
        }

        result := &amp;RecycleResult{
                TaskID:       task.ID,
                TableResults: make([]*TableRecycleResult, 0, len(task.Tables)),
        }

        // 通知进度开始
        r.notifyProgress(task.Progress)

        startTime := time.Now()

        // 根据模式执行回收
        switch task.Target.Mode </span>{
        case ModeIndependent:<span class="cov0" title="0">
                err := r.executeIndependentMode(ctx, task, result)
                if err != nil </span><span class="cov0" title="0">{
                        task.Status = StatusFailed
                        task.Error = err.Error()
                        return result, err
                }</span>
        case ModeReplication:<span class="cov0" title="0">
                err := r.executeReplicationMode(ctx, task, result)
                if err != nil </span><span class="cov0" title="0">{
                        task.Status = StatusFailed
                        task.Error = err.Error()
                        return result, err
                }</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unsupported recycle mode: %d", task.Target.Mode)</span>
        }

        // 完成任务
        <span class="cov0" title="0">result.TotalTime = time.Since(startTime)
        result.ProcessedTables = len(result.TableResults)

        for _, tr := range result.TableResults </span><span class="cov0" title="0">{
                if tr.Status == "success" </span><span class="cov0" title="0">{
                        result.SuccessfulTables++
                        result.ReclaimedSpace += tr.ReclaimedSpace
                }</span> else<span class="cov0" title="0"> if tr.Status == "failed" </span><span class="cov0" title="0">{
                        result.FailedTables++
                }</span> else<span class="cov0" title="0"> {
                        result.SkippedTables++
                }</span>
        }

        <span class="cov0" title="0">task.Status = StatusCompleted
        task.Result = result

        // 最终进度通知
        task.Progress.CompletedTables = result.ProcessedTables
        task.Progress.ReclaimedSpace = result.ReclaimedSpace
        task.Progress.LastUpdate = time.Now()
        r.notifyProgress(task.Progress)

        return result, nil</span>
}

// executeIndependentMode 执行独立节点模式
func (r *DefaultTablespaceRecycler) executeIndependentMode(ctx context.Context, task *RecycleTask, result *RecycleResult) error <span class="cov0" title="0">{
        conn, err := r.connectionFactory.CreateConnection(task.Target.Node)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect: %w", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // 关闭binlog记录
        if !task.Target.DryRun </span><span class="cov0" title="0">{
                _, err = conn.Query("SET SESSION sql_log_bin = OFF")
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to disable binlog: %w", err)
                }</span>
        }

        // 并发处理表
        <span class="cov0" title="0">return r.processTablesWithConcurrency(ctx, task, result, conn)</span>
}

// executeReplicationMode 执行复制同步模式
func (r *DefaultTablespaceRecycler) executeReplicationMode(ctx context.Context, task *RecycleTask, result *RecycleResult) error <span class="cov0" title="0">{
        conn, err := r.connectionFactory.CreateConnection(task.Target.Node)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to connect: %w", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // 保持binlog开启，串行处理以避免过大的复制延迟
        return r.processTablesSequentially(ctx, task, result, conn)</span>
}

// processTablesWithConcurrency 并发处理表
func (r *DefaultTablespaceRecycler) processTablesWithConcurrency(ctx context.Context, task *RecycleTask, result *RecycleResult, conn DBConnection) error <span class="cov0" title="0">{
        concurrency := task.Target.Concurrency
        if concurrency &lt;= 0 </span><span class="cov0" title="0">{
                concurrency = 3 // 默认并发数
        }</span>

        // 创建信号量控制并发
        <span class="cov0" title="0">sem := make(chan struct{}, concurrency)
        var wg sync.WaitGroup
        var mu sync.Mutex

        for i, table := range task.Tables </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                case sem &lt;- struct{}{}:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">wg.Add(1)
                go func(idx int, tbl *TableFragmentation) </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                &lt;-sem
                                wg.Done()
                        }</span>()

                        // 更新当前处理的表
                        <span class="cov0" title="0">task.Progress.CurrentTable = fmt.Sprintf("%s.%s", tbl.Schema, tbl.TableName)
                        task.Progress.CurrentTableSize = tbl.TotalSize
                        r.notifyProgress(task.Progress)

                        // 回收表
                        tableResult := r.recycleTableInternal(ctx, task.Target, tbl, conn)

                        // 更新结果
                        mu.Lock()
                        result.TableResults = append(result.TableResults, tableResult)
                        task.Progress.CompletedTables = len(result.TableResults)
                        task.Progress.ProcessedSize += tbl.TotalSize
                        if tableResult.Status == "success" </span><span class="cov0" title="0">{
                                task.Progress.ReclaimedSpace += tableResult.ReclaimedSpace
                        }</span>
                        <span class="cov0" title="0">task.Progress.LastUpdate = time.Now()

                        // 估算剩余时间
                        if task.Progress.CompletedTables &gt; 0 </span><span class="cov0" title="0">{
                                avgTime := time.Since(task.Progress.StartTime) / time.Duration(task.Progress.CompletedTables)
                                remaining := len(task.Tables) - task.Progress.CompletedTables
                                task.Progress.EstimatedRemaining = avgTime * time.Duration(remaining)
                        }</span>
                        <span class="cov0" title="0">mu.Unlock()

                        r.notifyProgress(task.Progress)

                        time.Sleep(30 * time.Second)</span>

                }(i, table)
        }

        <span class="cov0" title="0">wg.Wait()
        return nil</span>
}

// processTablesSequentially 串行处理表
func (r *DefaultTablespaceRecycler) processTablesSequentially(ctx context.Context, task *RecycleTask, result *RecycleResult, conn DBConnection) error <span class="cov0" title="0">{
        for i, table := range task.Tables </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                // 更新进度
                <span class="cov0" title="0">task.Progress.CurrentTable = fmt.Sprintf("%s.%s", table.Schema, table.TableName)
                task.Progress.CurrentTableSize = table.TotalSize
                task.Progress.CompletedTables = i
                r.notifyProgress(task.Progress)

                // 回收表
                tableResult := r.recycleTableInternal(ctx, task.Target, table, conn)
                result.TableResults = append(result.TableResults, tableResult)

                // 更新统计
                task.Progress.ProcessedSize += table.TotalSize
                if tableResult.Status == "success" </span><span class="cov0" title="0">{
                        task.Progress.ReclaimedSpace += tableResult.ReclaimedSpace
                }</span>

                // 估算剩余时间
                <span class="cov0" title="0">if i &gt; 0 </span><span class="cov0" title="0">{
                        avgTime := time.Since(task.Progress.StartTime) / time.Duration(i+1)
                        remaining := len(task.Tables) - i - 1
                        task.Progress.EstimatedRemaining = avgTime * time.Duration(remaining)
                }</span>

                <span class="cov0" title="0">task.Progress.LastUpdate = time.Now()
                r.notifyProgress(task.Progress)</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// RecycleTable 回收单个表
func (r *DefaultTablespaceRecycler) RecycleTable(ctx context.Context, target *RecycleTarget, table *TableFragmentation) (*TableRecycleResult, error) <span class="cov0" title="0">{
        // 为 ALTER TABLE 操作创建专用连接，使用 ALTER 超时
        conn, err := r.createAlterConnection(target.Node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to connect: %w", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        return r.recycleTableInternal(ctx, target, table, conn), nil</span>
}

// createAlterConnection 创建 ALTER TABLE 专用连接
func (r *DefaultTablespaceRecycler) createAlterConnection(node *cluster.NodeConfig) (DBConnection, error) <span class="cov0" title="0">{
        // 创建使用 ALTER 超时的节点配置副本
        alterNodeConfig := &amp;cluster.NodeConfig{
                Host:     node.Host,
                Port:     node.Port,
                Username: node.Username,
                Password: node.Password,
                Database: node.Database,
                Timeout:  node.Timeout,

                ConnectTimeout: node.ConnectTimeout,
                // 对于 ALTER TABLE 操作，使用 ALTER 超时作为查询超时
                QueryTimeout:     node.AlterTimeout,
                AlterTimeout:     node.AlterTimeout,
                DiscoveryTimeout: node.DiscoveryTimeout,
        }

        return r.connectionFactory.CreateConnection(alterNodeConfig)
}</span>

// recycleTableInternal 内部表回收实现
func (r *DefaultTablespaceRecycler) recycleTableInternal(ctx context.Context, target *RecycleTarget, table *TableFragmentation, conn DBConnection) *TableRecycleResult <span class="cov0" title="0">{
        result := &amp;TableRecycleResult{
                Schema:     table.Schema,
                TableName:  table.TableName,
                BeforeSize: table.TotalSize,
                Status:     "failed",
        }

        startTime := time.Now()
        defer func() </span><span class="cov0" title="0">{
                result.Duration = time.Since(startTime)
        }</span>()

        // 检查表是否被锁定
        <span class="cov0" title="0">if err := r.checkTableLocks(ctx, conn, table.Schema, table.TableName); err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Sprintf("table is locked: %v", err)
                return result
        }</span>

        // 模拟运行模式
        <span class="cov0" title="0">if target.DryRun </span><span class="cov0" title="0">{
                result.Status = "dry_run"
                result.ReclaimedSpace = int64(float64(table.DataFree) * 0.85) // 估算85%的回收率
                result.AfterSize = result.BeforeSize - result.ReclaimedSpace
                return result
        }</span>

        // 执行ALTER TABLE重建
        <span class="cov0" title="0">alterSQL := fmt.Sprintf("ALTER TABLE `%s`.`%s` ENGINE = %s",
                table.Schema, table.TableName, table.Engine)

        _, err := conn.Query(alterSQL)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Sprintf("alter table failed: %v", err)
                return result
        }</span>

        // 获取回收后的表信息
        <span class="cov0" title="0">updatedTable, err := r.analyzer.GetTableFragmentation(ctx, target.Node, table.Schema, table.TableName)
        if err != nil </span><span class="cov0" title="0">{
                result.Error = fmt.Sprintf("failed to get updated table info: %v", err)
                return result
        }</span>

        <span class="cov0" title="0">result.AfterSize = updatedTable.TotalSize
        result.ReclaimedSpace = result.BeforeSize - result.AfterSize
        result.Status = "success"

        return result</span>
}

// checkTableLocks 检查表锁状态
func (r *DefaultTablespaceRecycler) checkTableLocks(ctx context.Context, conn DBConnection, schema, table string) error <span class="cov0" title="0">{
        query := `
                SELECT COUNT(*) 
                FROM information_schema.INNODB_LOCKS 
                WHERE lock_table = CONCAT(?, '.', ?)
        `

        var lockCount int
        err := conn.QueryRow(query, schema, table).Scan(&amp;lockCount)
        if err != nil &amp;&amp; err != sql.ErrNoRows </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check locks: %w", err)
        }</span>

        <span class="cov0" title="0">if lockCount &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("table has %d active locks", lockCount)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// ValidateTarget 验证回收目标
func (r *DefaultTablespaceRecycler) ValidateTarget(ctx context.Context, target *RecycleTarget) error <span class="cov0" title="0">{
        if target.Node == nil </span><span class="cov0" title="0">{
                return fmt.Errorf("target node is nil")
        }</span>

        // 安全检查
        <span class="cov0" title="0">if target.SafetyChecks &amp;&amp; r.validator != nil </span><span class="cov0" title="0">{
                if err := r.validator.ValidateMasterSafety(ctx, target.Node); err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("safety validation failed: %w", err)
                }</span>
        }

        // 验证连接
        <span class="cov0" title="0">conn, err := r.connectionFactory.CreateConnection(target.Node)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("connection test failed: %w", err)
        }</span>
        <span class="cov0" title="0">defer conn.Close()

        // 检查权限
        if err := r.checkPermissions(ctx, conn); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("permission check failed: %w", err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// checkPermissions 检查所需权限
func (r *DefaultTablespaceRecycler) checkPermissions(ctx context.Context, conn DBConnection) error <span class="cov0" title="0">{
        // 检查ALTER权限
        _, err := conn.Query("SHOW GRANTS")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to check grants: %w", err)
        }</span>

        // 这里可以添加更详细的权限检查逻辑
        <span class="cov0" title="0">return nil</span>
}

// EstimateRecycleTime 估算回收时间
func (r *DefaultTablespaceRecycler) EstimateRecycleTime(target *RecycleTarget) (time.Duration, error) <span class="cov0" title="0">{
        if len(target.Tables) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">var totalTime time.Duration

        // 根据历史数据或表大小估算时间
        // 简化实现：每GB数据约需要2分钟
        var totalSize int64
        // 这里需要访问target中的表信息，暂时用简化逻辑
        totalSize = 1024 * 1024 * 1024 // 假设1GB

        estimatedMinutes := float64(totalSize) / float64(1024*1024*1024) * 2
        totalTime = time.Duration(estimatedMinutes) * time.Minute

        // 考虑并发因子
        if target.Concurrency &gt; 1 </span><span class="cov0" title="0">{
                totalTime = totalTime / time.Duration(target.Concurrency)
        }</span>

        <span class="cov0" title="0">return totalTime, nil</span>
}

// notifyProgress 通知进度更新
func (r *DefaultTablespaceRecycler) notifyProgress(progress *TaskProgress) <span class="cov0" title="0">{
        r.mu.RLock()
        callbacks := r.progressCallbacks
        r.mu.RUnlock()

        for _, callback := range callbacks </span><span class="cov0" title="0">{
                go callback(progress)
        }</span>
}

// GetActiveTask 获取活跃任务
func (r *DefaultTablespaceRecycler) GetActiveTask(taskID string) *RecycleTask <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        return r.activeTasks[taskID]
}</span>

// GetActiveTasks 获取所有活跃任务
func (r *DefaultTablespaceRecycler) GetActiveTasks() []*RecycleTask <span class="cov0" title="0">{
        r.mu.RLock()
        defer r.mu.RUnlock()

        tasks := make([]*RecycleTask, 0, len(r.activeTasks))
        for _, task := range r.activeTasks </span><span class="cov0" title="0">{
                tasks = append(tasks, task)
        }</span>

        <span class="cov0" title="0">return tasks</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">package recycler

import (
        "context"
        "fmt"
        "time"

        "mysql_tablespace_recycling/pkg/database"
)

// TableFragmentation 表碎片信息
type TableFragmentation struct {
        Schema            string    `json:"schema"`
        TableName         string    `json:"table_name"`
        Engine            string    `json:"engine"`
        TableRows         int64     `json:"table_rows"`
        AvgRowLength      int64     `json:"avg_row_length"`
        DataLength        int64     `json:"data_length"`
        MaxDataLength     int64     `json:"max_data_length"`
        IndexLength       int64     `json:"index_length"`
        DataFree          int64     `json:"data_free"`
        AutoIncrement     *int64     `json:"auto_increment,omitempty"`
        CreateTime        *time.Time `json:"create_time,omitempty"`
        UpdateTime        *time.Time `json:"update_time,omitempty"`
        CheckTime         *time.Time `json:"check_time,omitempty"`
        TableCollation    string    `json:"table_collation"`
        Checksum          *int64    `json:"checksum,omitempty"`
        CreateOptions     string    `json:"create_options"`
        TableComment      string    `json:"table_comment"`
        // 计算字段
        TotalSize         int64     `json:"total_size"`         // data_length + index_length
        FragmentRatio     float64   `json:"fragment_ratio"`     // data_free / total_size
        FragmentSize      int64     `json:"fragment_size"`      // data_free
        WastedRatio       float64   `json:"wasted_ratio"`       // fragment_ratio
        EstimatedRows     int64     `json:"estimated_rows"`     // 估算的行数
        EfficiencyRatio   float64   `json:"efficiency_ratio"`   // 数据利用效率
}

// FragmentationAnalysisOptions 碎片分析选项
type FragmentationAnalysisOptions struct {
        MinFragmentSize   int64    `json:"min_fragment_size"`   // 最小碎片大小阈值
        MinFragmentRatio  float64  `json:"min_fragment_ratio"`  // 最小碎片比例阈值
        MinTableSize      int64    `json:"min_table_size"`      // 最小表大小
        MaxTableSize      int64    `json:"max_table_size"`      // 最大表大小  
        IncludeSchemas    []string `json:"include_schemas"`     // 包含的数据库
        ExcludeSchemas    []string `json:"exclude_schemas"`     // 排除的数据库
        IncludeTables     []string `json:"include_tables"`      // 包含的表（支持通配符）
        ExcludeTables     []string `json:"exclude_tables"`      // 排除的表（支持通配符）
        SupportedEngines  []string `json:"supported_engines"`   // 支持的存储引擎
        SortBy            string   `json:"sort_by"`             // 排序字段
        SortOrder         string   `json:"sort_order"`          // 排序顺序
        Limit             int      `json:"limit"`               // 限制返回数量
}

// FragmentationReport 碎片分析报告
type FragmentationReport struct {
        NodeHost              string                  `json:"node_host"`
        NodePort              int                     `json:"node_port"`
        AnalysisTime          time.Time              `json:"analysis_time"`
        TotalTables           int                     `json:"total_tables"`
        FragmentedTables      []*TableFragmentation   `json:"fragmented_tables"`
        TotalFragmentSize     int64                  `json:"total_fragment_size"`
        TotalDataSize         int64                  `json:"total_data_size"`
        TotalIndexSize        int64                  `json:"total_index_size"`
        EstimatedReclaimableSpace int64              `json:"estimated_reclaimable_space"`
        AverageFragmentRatio  float64                `json:"average_fragment_ratio"`
        LargestFragmentTable  *TableFragmentation     `json:"largest_fragment_table,omitempty"`
        HighestRatioTable     *TableFragmentation     `json:"highest_ratio_table,omitempty"`
        RecommendedActions    []string               `json:"recommended_actions"`
        AnalysisOptions       *FragmentationAnalysisOptions `json:"analysis_options"`
}

// FragmentationAnalyzer 表空间碎片分析器接口
type FragmentationAnalyzer interface {
        AnalyzeFragmentation(ctx context.Context, nodeConfig database.NodeConfigInterface, options *FragmentationAnalysisOptions) (*FragmentationReport, error)
        GetTableFragmentation(ctx context.Context, nodeConfig database.NodeConfigInterface, schema, tableName string) (*TableFragmentation, error)
        GetSchemaFragmentation(ctx context.Context, nodeConfig database.NodeConfigInterface, schema string, options *FragmentationAnalysisOptions) ([]*TableFragmentation, error)
        EstimateReclaimBenefit(fragmentation *TableFragmentation) (*ReclaimBenefit, error)
}

// ReclaimBenefit 回收收益评估
type ReclaimBenefit struct {
        EstimatedReclaimedSpace int64         `json:"estimated_reclaimed_space"`
        EstimatedTimeCost       time.Duration `json:"estimated_time_cost"`
        Priority               int           `json:"priority"`
        RiskLevel              RiskLevel     `json:"risk_level"`
        Benefits               []string      `json:"benefits"`
        Risks                  []string      `json:"risks"`
        Recommendation         string        `json:"recommendation"`
}

// RiskLevel 风险等级
type RiskLevel string

const (
        RiskLow    RiskLevel = "low"
        RiskMedium RiskLevel = "medium"
        RiskHigh   RiskLevel = "high"
)

// CalculateFragmentationMetrics 计算碎片化指标
func (tf *TableFragmentation) CalculateFragmentationMetrics() <span class="cov8" title="1">{
        tf.TotalSize = tf.DataLength + tf.IndexLength
        
        if tf.TotalSize &gt; 0 </span><span class="cov8" title="1">{
                tf.FragmentRatio = float64(tf.DataFree) / float64(tf.TotalSize)
                tf.EfficiencyRatio = float64(tf.TotalSize-tf.DataFree) / float64(tf.TotalSize)
        }</span>
        
        <span class="cov8" title="1">tf.FragmentSize = tf.DataFree
        tf.WastedRatio = tf.FragmentRatio
        
        // 估算行数
        if tf.AvgRowLength &gt; 0 </span><span class="cov8" title="1">{
                tf.EstimatedRows = tf.DataLength / tf.AvgRowLength
        }</span>
}

// IsFragmented 检查表是否需要碎片整理
func (tf *TableFragmentation) IsFragmented(options *FragmentationAnalysisOptions) bool <span class="cov8" title="1">{
        // 检查最小碎片大小
        if tf.DataFree &lt; options.MinFragmentSize </span><span class="cov8" title="1">{
                return false
        }</span>
        
        // 检查最小碎片比例
        <span class="cov8" title="1">if tf.FragmentRatio &lt; options.MinFragmentRatio </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // 检查表大小范围
        <span class="cov8" title="1">if tf.TotalSize &lt; options.MinTableSize || 
           (options.MaxTableSize &gt; 0 &amp;&amp; tf.TotalSize &gt; options.MaxTableSize) </span><span class="cov0" title="0">{
                return false
        }</span>
        
        // 检查存储引擎
        <span class="cov8" title="1">if len(options.SupportedEngines) &gt; 0 </span><span class="cov8" title="1">{
                supported := false
                for _, engine := range options.SupportedEngines </span><span class="cov8" title="1">{
                        if tf.Engine == engine </span><span class="cov8" title="1">{
                                supported = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !supported </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        
        <span class="cov8" title="1">return true</span>
}

// GetFragmentationSeverity 获取碎片化严重程度
func (tf *TableFragmentation) GetFragmentationSeverity() string <span class="cov8" title="1">{
        if tf.FragmentRatio &gt;= 0.3 </span><span class="cov8" title="1">{
                return "severe"
        }</span> else<span class="cov8" title="1"> if tf.FragmentRatio &gt;= 0.15 </span><span class="cov8" title="1">{
                return "moderate"
        }</span> else<span class="cov8" title="1"> if tf.FragmentRatio &gt;= 0.05 </span><span class="cov8" title="1">{
                return "mild"
        }</span>
        <span class="cov8" title="1">return "minimal"</span>
}

// String 返回表碎片信息的字符串表示
func (tf *TableFragmentation) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s.%s: %s engine, %.2f%% fragmented (%s), %s total, %s free",
                tf.Schema, tf.TableName, tf.Engine, tf.FragmentRatio*100,
                tf.GetFragmentationSeverity(), 
                formatBytes(tf.TotalSize), formatBytes(tf.DataFree))
}</span>

// formatBytes 格式化字节数
func formatBytes(bytes int64) string <span class="cov8" title="1">{
        if bytes &lt; 1024 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%d B", bytes)
        }</span> else<span class="cov8" title="1"> if bytes &lt; 1024*1024 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%.1f KB", float64(bytes)/1024)
        }</span> else<span class="cov8" title="1"> if bytes &lt; 1024*1024*1024 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%.1f MB", float64(bytes)/(1024*1024))
        }</span> else<span class="cov8" title="1"> {
                return fmt.Sprintf("%.2f GB", float64(bytes)/(1024*1024*1024))
        }</span>
}

// GetDefaultAnalysisOptions 获取默认分析选项
func GetDefaultAnalysisOptions() *FragmentationAnalysisOptions <span class="cov8" title="1">{
        return &amp;FragmentationAnalysisOptions{
                MinFragmentSize:  100 * 1024 * 1024, // 100MB
                MinFragmentRatio: 0.05,              // 5%
                MinTableSize:     10 * 1024 * 1024,  // 10MB
                MaxTableSize:     0,                 // 无限制
                SupportedEngines: []string{"InnoDB", "MyISAM"},
                SortBy:          "fragment_size",
                SortOrder:       "desc",
                Limit:           0, // 无限制
        }
}</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
